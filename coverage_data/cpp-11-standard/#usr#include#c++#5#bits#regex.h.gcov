        -:    0:Source:/usr/include/c++/5/bits/regex.h
        -:    0:Graph:./test_index.gcno
        -:    0:Data:./test_index.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// class template regex -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2010-2015 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/**
        -:   26: *  @file bits/regex.h
        -:   27: *  This is an internal header file, included by other library headers.
        -:   28: *  Do not attempt to use it directly. @headername{regex}
        -:   29: */
        -:   30:
        -:   31:namespace std _GLIBCXX_VISIBILITY(default)
        -:   32:{
        -:   33:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   34:_GLIBCXX_BEGIN_NAMESPACE_CXX11
        -:   35:  template<typename, typename>
        -:   36:    class basic_regex;
        -:   37:
        -:   38:  template<typename, typename>
        -:   39:    class match_results;
        -:   40:
        -:   41:_GLIBCXX_END_NAMESPACE_CXX11
        -:   42:_GLIBCXX_END_NAMESPACE_VERSION
        -:   43:
        -:   44:namespace __detail
        -:   45:{
        -:   46:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   47:
        -:   48:  enum class _RegexExecutorPolicy : int
        -:   49:    { _S_auto, _S_alternate };
        -:   50:
        -:   51:  template<typename _BiIter, typename _Alloc,
        -:   52:	   typename _CharT, typename _TraitsT,
        -:   53:	   _RegexExecutorPolicy __policy,
        -:   54:	   bool __match_mode>
        -:   55:    bool
        -:   56:    __regex_algo_impl(_BiIter                              __s,
        -:   57:		      _BiIter                              __e,
        -:   58:		      match_results<_BiIter, _Alloc>&      __m,
        -:   59:		      const basic_regex<_CharT, _TraitsT>& __re,
        -:   60:		      regex_constants::match_flag_type     __flags);
        -:   61:
        -:   62:  template<typename, typename, typename, bool>
        -:   63:    class _Executor;
        -:   64:
        -:   65:_GLIBCXX_END_NAMESPACE_VERSION
        -:   66:}
        -:   67:
        -:   68:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   69:_GLIBCXX_BEGIN_NAMESPACE_CXX11
        -:   70:
        -:   71:  /**
        -:   72:   * @addtogroup regex
        -:   73:   * @{
        -:   74:   */
        -:   75:
        -:   76:  /**
        -:   77:   * @brief Describes aspects of a regular expression.
        -:   78:   *
        -:   79:   * A regular expression traits class that satisfies the requirements of
        -:   80:   * section [28.7].
        -:   81:   *
        -:   82:   * The class %regex is parameterized around a set of related types and
        -:   83:   * functions used to complete the definition of its semantics.  This class
        -:   84:   * satisfies the requirements of such a traits class.
        -:   85:   */
        -:   86:  template<typename _Ch_type>
function _ZNSt7__cxx1112regex_traitsIcED2Ev called 0 returned 0% blocks executed 0%
    #####:   87:    struct regex_traits
call    0 never executed
        -:   88:    {
        -:   89:    public:
        -:   90:      typedef _Ch_type                     	char_type;
        -:   91:      typedef std::basic_string<char_type> 	string_type;
        -:   92:      typedef std::locale                  	locale_type;
        -:   93:    private:
        -:   94:      struct _RegexMask
        -:   95:	{
        -:   96:	  typedef std::ctype_base::mask _BaseType;
        -:   97:	  _BaseType _M_base;
        -:   98:	  unsigned char _M_extended;
        -:   99:	  static constexpr unsigned char _S_under = 1 << 0;
        -:  100:	  static constexpr unsigned char _S_valid_mask = 0x1;
        -:  101:
function _ZNSt7__cxx1112regex_traitsIcE10_RegexMaskC2Eth called 0 returned 0% blocks executed 0%
    #####:  102:	  constexpr _RegexMask(_BaseType __base = 0,
        -:  103:			       unsigned char __extended = 0)
    #####:  104:	  : _M_base(__base), _M_extended(__extended)
    #####:  105:	  { }
        -:  106:
        -:  107:	  constexpr _RegexMask
function _ZNKSt7__cxx1112regex_traitsIcE10_RegexMaskanES2_ called 0 returned 0% blocks executed 0%
    #####:  108:	  operator&(_RegexMask __other) const
        -:  109:	  {
    #####:  110:	    return _RegexMask(_M_base & __other._M_base,
    #####:  111:			      _M_extended & __other._M_extended);
call    0 never executed
        -:  112:	  }
        -:  113:
        -:  114:	  constexpr _RegexMask
function _ZNKSt7__cxx1112regex_traitsIcE10_RegexMaskorES2_ called 0 returned 0% blocks executed 0%
    #####:  115:	  operator|(_RegexMask __other) const
        -:  116:	  {
    #####:  117:	    return _RegexMask(_M_base | __other._M_base,
    #####:  118:			      _M_extended | __other._M_extended);
call    0 never executed
        -:  119:	  }
        -:  120:
        -:  121:	  constexpr _RegexMask
        -:  122:	  operator^(_RegexMask __other) const
        -:  123:	  {
        -:  124:	    return _RegexMask(_M_base ^ __other._M_base,
        -:  125:			      _M_extended ^ __other._M_extended);
        -:  126:	  }
        -:  127:
        -:  128:	  constexpr _RegexMask
        -:  129:	  operator~() const
        -:  130:	  { return _RegexMask(~_M_base, ~_M_extended); }
        -:  131:
        -:  132:	  _RegexMask&
        -:  133:	  operator&=(_RegexMask __other)
        -:  134:	  { return *this = (*this) & __other; }
        -:  135:
        -:  136:	  _RegexMask&
function _ZNSt7__cxx1112regex_traitsIcE10_RegexMaskoRES2_ called 0 returned 0% blocks executed 0%
    #####:  137:	  operator|=(_RegexMask __other)
    #####:  138:	  { return *this = (*this) | __other; }
call    0 never executed
        -:  139:
        -:  140:	  _RegexMask&
        -:  141:	  operator^=(_RegexMask __other)
        -:  142:	  { return *this = (*this) ^ __other; }
        -:  143:
        -:  144:	  constexpr bool
function _ZNKSt7__cxx1112regex_traitsIcE10_RegexMaskeqES2_ called 0 returned 0% blocks executed 0%
    #####:  145:	  operator==(_RegexMask __other) const
        -:  146:	  {
    #####:  147:	    return (_M_extended & _S_valid_mask)
    #####:  148:		   == (__other._M_extended & _S_valid_mask)
    #####:  149:		     && _M_base == __other._M_base;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  150:	  }
        -:  151:
        -:  152:	  constexpr bool
function _ZNKSt7__cxx1112regex_traitsIcE10_RegexMaskneES2_ called 0 returned 0% blocks executed 0%
    #####:  153:	  operator!=(_RegexMask __other) const
    #####:  154:	  { return !((*this) == __other); }
call    0 never executed
        -:  155:
        -:  156:	};
        -:  157:    public:
        -:  158:      typedef _RegexMask char_class_type;
        -:  159:
        -:  160:    public:
        -:  161:      /**
        -:  162:       * @brief Constructs a default traits object.
        -:  163:       */
function _ZNSt7__cxx1112regex_traitsIcEC2Ev called 0 returned 0% blocks executed 0%
    #####:  164:      regex_traits() { }
call    0 never executed
        -:  165:
        -:  166:      /**
        -:  167:       * @brief Gives the length of a C-style string starting at @p __p.
        -:  168:       *
        -:  169:       * @param __p a pointer to the start of a character sequence.
        -:  170:       *
        -:  171:       * @returns the number of characters between @p *__p and the first
        -:  172:       * default-initialized value of type @p char_type.  In other words, uses
        -:  173:       * the C-string algorithm for determining the length of a sequence of
        -:  174:       * characters.
        -:  175:       */
        -:  176:      static std::size_t
        -:  177:      length(const char_type* __p)
        -:  178:      { return string_type::traits_type::length(__p); }
        -:  179:
        -:  180:      /**
        -:  181:       * @brief Performs the identity translation.
        -:  182:       *
        -:  183:       * @param __c A character to the locale-specific character set.
        -:  184:       *
        -:  185:       * @returns __c.
        -:  186:       */
        -:  187:      char_type
function _ZNKSt7__cxx1112regex_traitsIcE9translateEc called 0 returned 0% blocks executed 0%
    #####:  188:      translate(char_type __c) const
    #####:  189:      { return __c; }
        -:  190:
        -:  191:      /**
        -:  192:       * @brief Translates a character into a case-insensitive equivalent.
        -:  193:       *
        -:  194:       * @param __c A character to the locale-specific character set.
        -:  195:       *
        -:  196:       * @returns the locale-specific lower-case equivalent of __c.
        -:  197:       * @throws std::bad_cast if the imbued locale does not support the ctype
        -:  198:       *         facet.
        -:  199:       */
        -:  200:      char_type
function _ZNKSt7__cxx1112regex_traitsIcE16translate_nocaseEc called 0 returned 0% blocks executed 0%
    #####:  201:      translate_nocase(char_type __c) const
        -:  202:      {
        -:  203:	typedef std::ctype<char_type> __ctype_type;
    #####:  204:	const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));
call    0 never executed
    #####:  205:	return __fctyp.tolower(__c);
call    0 never executed
        -:  206:      }
        -:  207:
        -:  208:      /**
        -:  209:       * @brief Gets a sort key for a character sequence.
        -:  210:       *
        -:  211:       * @param __first beginning of the character sequence.
        -:  212:       * @param __last  one-past-the-end of the character sequence.
        -:  213:       *
        -:  214:       * Returns a sort key for the character sequence designated by the
        -:  215:       * iterator range [F1, F2) such that if the character sequence [G1, G2)
        -:  216:       * sorts before the character sequence [H1, H2) then
        -:  217:       * v.transform(G1, G2) < v.transform(H1, H2).
        -:  218:       *
        -:  219:       * What this really does is provide a more efficient way to compare a
        -:  220:       * string to multiple other strings in locales with fancy collation
        -:  221:       * rules and equivalence classes.
        -:  222:       *
        -:  223:       * @returns a locale-specific sort key equivalent to the input range.
        -:  224:       *
        -:  225:       * @throws std::bad_cast if the current locale does not have a collate
        -:  226:       *         facet.
        -:  227:       */
        -:  228:      template<typename _Fwd_iter>
        -:  229:	string_type
function _ZNKSt7__cxx1112regex_traitsIcE9transformIN9__gnu_cxx17__normal_iteratorIPcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEEEESA_T_SC_ called 0 returned 0% blocks executed 0%
function _ZNKSt7__cxx1112regex_traitsIcE9transformIPcEENS_12basic_stringIcSt11char_traitsIcESaIcEEET_S9_ called 0 returned 0% blocks executed 0%
function _ZNKSt7__cxx1112regex_traitsIcE9transformIN9__gnu_cxx17__normal_iteratorIPKcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEEEESB_T_SD_ called 0 returned 0% blocks executed 0%
    #####:  230:	transform(_Fwd_iter __first, _Fwd_iter __last) const
        -:  231:	{
        -:  232:	  typedef std::collate<char_type> __collate_type;
    #####:  233:	  const __collate_type& __fclt(use_facet<__collate_type>(_M_locale));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  234:	  string_type __s(__first, __last);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
    #####:  235:	  return __fclt.transform(__s.data(), __s.data() + __s.size());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
branch 18 never executed
branch 19 never executed
call   20 never executed
        -:  236:	}
        -:  237:
        -:  238:      /**
        -:  239:       * @brief Gets a sort key for a character sequence, independent of case.
        -:  240:       *
        -:  241:       * @param __first beginning of the character sequence.
        -:  242:       * @param __last  one-past-the-end of the character sequence.
        -:  243:       *
        -:  244:       * Effects: if typeid(use_facet<collate<_Ch_type> >) ==
        -:  245:       * typeid(collate_byname<_Ch_type>) and the form of the sort key
        -:  246:       * returned by collate_byname<_Ch_type>::transform(__first, __last)
        -:  247:       * is known and can be converted into a primary sort key
        -:  248:       * then returns that key, otherwise returns an empty string.
        -:  249:       *
        -:  250:       * @todo Implement this function correctly.
        -:  251:       */
        -:  252:      template<typename _Fwd_iter>
        -:  253:	string_type
function _ZNKSt7__cxx1112regex_traitsIcE17transform_primaryIPKcEENS_12basic_stringIcSt11char_traitsIcESaIcEEET_SA_ called 0 returned 0% blocks executed 0%
function _ZNKSt7__cxx1112regex_traitsIcE17transform_primaryIPcEENS_12basic_stringIcSt11char_traitsIcESaIcEEET_S9_ called 0 returned 0% blocks executed 0%
    #####:  254:	transform_primary(_Fwd_iter __first, _Fwd_iter __last) const
        -:  255:	{
        -:  256:	  // TODO : this is not entirely correct.
        -:  257:	  // This function requires extra support from the platform.
        -:  258:	  //
        -:  259:	  // Read http://gcc.gnu.org/ml/libstdc++/2013-09/msg00117.html and
        -:  260:	  // http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2003/n1429.htm
        -:  261:	  // for details.
        -:  262:	  typedef std::ctype<char_type> __ctype_type;
    #####:  263:	  const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  264:	  std::vector<char_type> __s(__first, __last);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
    #####:  265:	  __fctyp.tolower(__s.data(), __s.data() + __s.size());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
    #####:  266:	  return this->transform(__s.data(), __s.data() + __s.size());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
        -:  267:	}
        -:  268:
        -:  269:      /**
        -:  270:       * @brief Gets a collation element by name.
        -:  271:       *
        -:  272:       * @param __first beginning of the collation element name.
        -:  273:       * @param __last  one-past-the-end of the collation element name.
        -:  274:       *
        -:  275:       * @returns a sequence of one or more characters that represents the
        -:  276:       * collating element consisting of the character sequence designated by
        -:  277:       * the iterator range [__first, __last). Returns an empty string if the
        -:  278:       * character sequence is not a valid collating element.
        -:  279:       */
        -:  280:      template<typename _Fwd_iter>
        -:  281:	string_type
        -:  282:	lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const;
        -:  283:
        -:  284:      /**
        -:  285:       * @brief Maps one or more characters to a named character
        -:  286:       *        classification.
        -:  287:       *
        -:  288:       * @param __first beginning of the character sequence.
        -:  289:       * @param __last  one-past-the-end of the character sequence.
        -:  290:       * @param __icase ignores the case of the classification name.
        -:  291:       *
        -:  292:       * @returns an unspecified value that represents the character
        -:  293:       * classification named by the character sequence designated by
        -:  294:       * the iterator range [__first, __last). If @p icase is true,
        -:  295:       * the returned mask identifies the classification regardless of
        -:  296:       * the case of the characters to be matched (for example,
        -:  297:       * [[:lower:]] is the same as [[:alpha:]]), otherwise a
        -:  298:       * case-dependent classification is returned.  The value
        -:  299:       * returned shall be independent of the case of the characters
        -:  300:       * in the character sequence. If the name is not recognized then
        -:  301:       * returns a value that compares equal to 0.
        -:  302:       *
        -:  303:       * At least the following names (or their wide-character equivalent) are
        -:  304:       * supported.
        -:  305:       * - d
        -:  306:       * - w
        -:  307:       * - s
        -:  308:       * - alnum
        -:  309:       * - alpha
        -:  310:       * - blank
        -:  311:       * - cntrl
        -:  312:       * - digit
        -:  313:       * - graph
        -:  314:       * - lower
        -:  315:       * - print
        -:  316:       * - punct
        -:  317:       * - space
        -:  318:       * - upper
        -:  319:       * - xdigit
        -:  320:       */
        -:  321:      template<typename _Fwd_iter>
        -:  322:	char_class_type
        -:  323:	lookup_classname(_Fwd_iter __first, _Fwd_iter __last,
        -:  324:			 bool __icase = false) const;
        -:  325:
        -:  326:      /**
        -:  327:       * @brief Determines if @p c is a member of an identified class.
        -:  328:       *
        -:  329:       * @param __c a character.
        -:  330:       * @param __f a class type (as returned from lookup_classname).
        -:  331:       *
        -:  332:       * @returns true if the character @p __c is a member of the classification
        -:  333:       * represented by @p __f, false otherwise.
        -:  334:       *
        -:  335:       * @throws std::bad_cast if the current locale does not have a ctype
        -:  336:       *         facet.
        -:  337:       */
        -:  338:      bool
        -:  339:      isctype(_Ch_type __c, char_class_type __f) const;
        -:  340:
        -:  341:      /**
        -:  342:       * @brief Converts a digit to an int.
        -:  343:       *
        -:  344:       * @param __ch    a character representing a digit.
        -:  345:       * @param __radix the radix if the numeric conversion (limited to 8, 10,
        -:  346:       *              or 16).
        -:  347:       *
        -:  348:       * @returns the value represented by the digit __ch in base radix if the
        -:  349:       * character __ch is a valid digit in base radix; otherwise returns -1.
        -:  350:       */
        -:  351:      int
        -:  352:      value(_Ch_type __ch, int __radix) const;
        -:  353:
        -:  354:      /**
        -:  355:       * @brief Imbues the regex_traits object with a copy of a new locale.
        -:  356:       *
        -:  357:       * @param __loc A locale.
        -:  358:       *
        -:  359:       * @returns a copy of the previous locale in use by the regex_traits
        -:  360:       *          object.
        -:  361:       *
        -:  362:       * @note Calling imbue with a different locale than the one currently in
        -:  363:       *       use invalidates all cached data held by *this.
        -:  364:       */
        -:  365:      locale_type
function _ZNSt7__cxx1112regex_traitsIcE5imbueESt6locale called 0 returned 0% blocks executed 0%
    #####:  366:      imbue(locale_type __loc)
        -:  367:      {
    #####:  368:	std::swap(_M_locale, __loc);
call    0 never executed
    #####:  369:	return __loc;
call    0 never executed
        -:  370:      }
        -:  371:
        -:  372:      /**
        -:  373:       * @brief Gets a copy of the current locale in use by the regex_traits
        -:  374:       * object.
        -:  375:       */
        -:  376:      locale_type
        -:  377:      getloc() const
        -:  378:      { return _M_locale; }
        -:  379:
        -:  380:    protected:
        -:  381:      locale_type _M_locale;
        -:  382:    };
        -:  383:
        -:  384:  // [7.8] Class basic_regex
        -:  385:  /**
        -:  386:   * Objects of specializations of this class represent regular expressions
        -:  387:   * constructed from sequences of character type @p _Ch_type.
        -:  388:   *
        -:  389:   * Storage for the regular expression is allocated and deallocated as
        -:  390:   * necessary by the member functions of this class.
        -:  391:   */
        -:  392:  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type>>
        -:  393:    class basic_regex
        -:  394:    {
        -:  395:    public:
        -:  396:      static_assert(is_same<_Ch_type, typename _Rx_traits::char_type>::value,
        -:  397:		    "regex traits class must have the same char_type");
        -:  398:
        -:  399:      // types:
        -:  400:      typedef _Ch_type                            value_type;
        -:  401:      typedef _Rx_traits                          traits_type;
        -:  402:      typedef typename traits_type::string_type   string_type;
        -:  403:      typedef regex_constants::syntax_option_type flag_type;
        -:  404:      typedef typename traits_type::locale_type   locale_type;
        -:  405:
        -:  406:      /**
        -:  407:       * @name Constants
        -:  408:       * std [28.8.1](1)
        -:  409:       */
        -:  410:      //@{
        -:  411:      static constexpr flag_type icase = regex_constants::icase;
        -:  412:      static constexpr flag_type nosubs = regex_constants::nosubs;
        -:  413:      static constexpr flag_type optimize = regex_constants::optimize;
        -:  414:      static constexpr flag_type collate = regex_constants::collate;
        -:  415:      static constexpr flag_type ECMAScript = regex_constants::ECMAScript;
        -:  416:      static constexpr flag_type basic = regex_constants::basic;
        -:  417:      static constexpr flag_type extended = regex_constants::extended;
        -:  418:      static constexpr flag_type awk = regex_constants::awk;
        -:  419:      static constexpr flag_type grep = regex_constants::grep;
        -:  420:      static constexpr flag_type egrep = regex_constants::egrep;
        -:  421:      //@}
        -:  422:
        -:  423:      // [7.8.2] construct/copy/destroy
        -:  424:      /**
        -:  425:       * Constructs a basic regular expression that does not match any
        -:  426:       * character sequence.
        -:  427:       */
        -:  428:      basic_regex()
        -:  429:      : _M_flags(ECMAScript), _M_loc(), _M_automaton(nullptr)
        -:  430:      { }
        -:  431:
        -:  432:      /**
        -:  433:       * @brief Constructs a basic regular expression from the
        -:  434:       * sequence [__p, __p + char_traits<_Ch_type>::length(__p))
        -:  435:       * interpreted according to the flags in @p __f.
        -:  436:       *
        -:  437:       * @param __p A pointer to the start of a C-style null-terminated string
        -:  438:       *          containing a regular expression.
        -:  439:       * @param __f Flags indicating the syntax rules and options.
        -:  440:       *
        -:  441:       * @throws regex_error if @p __p is not a valid regular expression.
        -:  442:       */
        -:  443:      explicit
        -:  444:      basic_regex(const _Ch_type* __p, flag_type __f = ECMAScript)
        -:  445:      : basic_regex(__p, __p + char_traits<_Ch_type>::length(__p), __f)
        -:  446:      { }
        -:  447:
        -:  448:      /**
        -:  449:       * @brief Constructs a basic regular expression from the sequence
        -:  450:       * [p, p + len) interpreted according to the flags in @p f.
        -:  451:       *
        -:  452:       * @param __p   A pointer to the start of a string containing a regular
        -:  453:       *              expression.
        -:  454:       * @param __len The length of the string containing the regular
        -:  455:       *              expression.
        -:  456:       * @param __f   Flags indicating the syntax rules and options.
        -:  457:       *
        -:  458:       * @throws regex_error if @p __p is not a valid regular expression.
        -:  459:       */
        -:  460:      basic_regex(const _Ch_type* __p, std::size_t __len,
        -:  461:		  flag_type __f = ECMAScript)
        -:  462:      : basic_regex(__p, __p + __len, __f)
        -:  463:      { }
        -:  464:
        -:  465:      /**
        -:  466:       * @brief Copy-constructs a basic regular expression.
        -:  467:       *
        -:  468:       * @param __rhs A @p regex object.
        -:  469:       */
        -:  470:      basic_regex(const basic_regex& __rhs) = default;
        -:  471:
        -:  472:      /**
        -:  473:       * @brief Move-constructs a basic regular expression.
        -:  474:       *
        -:  475:       * @param __rhs A @p regex object.
        -:  476:       */
        -:  477:      basic_regex(basic_regex&& __rhs) noexcept = default;
        -:  478:
        -:  479:      /**
        -:  480:       * @brief Constructs a basic regular expression from the string
        -:  481:       * @p s interpreted according to the flags in @p f.
        -:  482:       *
        -:  483:       * @param __s A string containing a regular expression.
        -:  484:       * @param __f Flags indicating the syntax rules and options.
        -:  485:       *
        -:  486:       * @throws regex_error if @p __s is not a valid regular expression.
        -:  487:       */
        -:  488:      template<typename _Ch_traits, typename _Ch_alloc>
        -:  489:	explicit
function _ZNSt7__cxx1111basic_regexIcNS_12regex_traitsIcEEEC2ISt11char_traitsIcESaIcEEERKNS_12basic_stringIcT_T0_EENSt15regex_constants18syntax_option_typeE called 0 returned 0% blocks executed 0%
    #####:  490:	basic_regex(const std::basic_string<_Ch_type, _Ch_traits,
        -:  491:					    _Ch_alloc>& __s,
        -:  492:		    flag_type __f = ECMAScript)
    #####:  493:	: basic_regex(__s.data(), __s.data() + __s.size(), __f)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  494:	{ }
        -:  495:
        -:  496:      /**
        -:  497:       * @brief Constructs a basic regular expression from the range
        -:  498:       * [first, last) interpreted according to the flags in @p f.
        -:  499:       *
        -:  500:       * @param __first The start of a range containing a valid regular
        -:  501:       *                expression.
        -:  502:       * @param __last  The end of a range containing a valid regular
        -:  503:       *                expression.
        -:  504:       * @param __f     The format flags of the regular expression.
        -:  505:       *
        -:  506:       * @throws regex_error if @p [__first, __last) is not a valid regular
        -:  507:       *         expression.
        -:  508:       */
        -:  509:      template<typename _FwdIter>
function _ZNSt7__cxx1111basic_regexIcNS_12regex_traitsIcEEEC2IPKcEET_S7_NSt15regex_constants18syntax_option_typeE called 0 returned 0% blocks executed 0%
    #####:  510:	basic_regex(_FwdIter __first, _FwdIter __last,
        -:  511:		    flag_type __f = ECMAScript)
    #####:  512:	: basic_regex(std::move(__first), std::move(__last), locale_type(), __f)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
    #####:  513:	{ }
        -:  514:
        -:  515:      /**
        -:  516:       * @brief Constructs a basic regular expression from an initializer list.
        -:  517:       *
        -:  518:       * @param __l  The initializer list.
        -:  519:       * @param __f  The format flags of the regular expression.
        -:  520:       *
        -:  521:       * @throws regex_error if @p __l is not a valid regular expression.
        -:  522:       */
        -:  523:      basic_regex(initializer_list<_Ch_type> __l, flag_type __f = ECMAScript)
        -:  524:      : basic_regex(__l.begin(), __l.end(), __f)
        -:  525:      { }
        -:  526:
        -:  527:      /**
        -:  528:       * @brief Destroys a basic regular expression.
        -:  529:       */
function _ZNSt7__cxx1111basic_regexIcNS_12regex_traitsIcEEED2Ev called 0 returned 0% blocks executed 0%
    #####:  530:      ~basic_regex()
    #####:  531:      { }
call    0 never executed
call    1 never executed
        -:  532:
        -:  533:      /**
        -:  534:       * @brief Assigns one regular expression to another.
        -:  535:       */
        -:  536:      basic_regex&
        -:  537:      operator=(const basic_regex& __rhs)
        -:  538:      { return this->assign(__rhs); }
        -:  539:
        -:  540:      /**
        -:  541:       * @brief Move-assigns one regular expression to another.
        -:  542:       */
        -:  543:      basic_regex&
        -:  544:      operator=(basic_regex&& __rhs) noexcept
        -:  545:      { return this->assign(std::move(__rhs)); }
        -:  546:
        -:  547:      /**
        -:  548:       * @brief Replaces a regular expression with a new one constructed from
        -:  549:       * a C-style null-terminated string.
        -:  550:       *
        -:  551:       * @param __p A pointer to the start of a null-terminated C-style string
        -:  552:       *        containing a regular expression.
        -:  553:       */
        -:  554:      basic_regex&
        -:  555:      operator=(const _Ch_type* __p)
        -:  556:      { return this->assign(__p); }
        -:  557:
        -:  558:      /**
        -:  559:       * @brief Replaces a regular expression with a new one constructed from
        -:  560:       * an initializer list.
        -:  561:       *
        -:  562:       * @param __l  The initializer list.
        -:  563:       *
        -:  564:       * @throws regex_error if @p __l is not a valid regular expression.
        -:  565:       */
        -:  566:      basic_regex&
        -:  567:      operator=(initializer_list<_Ch_type> __l)
        -:  568:      { return this->assign(__l.begin(), __l.end()); }
        -:  569:
        -:  570:      /**
        -:  571:       * @brief Replaces a regular expression with a new one constructed from
        -:  572:       * a string.
        -:  573:       *
        -:  574:       * @param __s A pointer to a string containing a regular expression.
        -:  575:       */
        -:  576:      template<typename _Ch_traits, typename _Alloc>
        -:  577:	basic_regex&
        -:  578:	operator=(const basic_string<_Ch_type, _Ch_traits, _Alloc>& __s)
        -:  579:	{ return this->assign(__s); }
        -:  580:
        -:  581:      // [7.8.3] assign
        -:  582:      /**
        -:  583:       * @brief the real assignment operator.
        -:  584:       *
        -:  585:       * @param __rhs Another regular expression object.
        -:  586:       */
        -:  587:      basic_regex&
        -:  588:      assign(const basic_regex& __rhs)
        -:  589:      {
        -:  590:	basic_regex __tmp(__rhs);
        -:  591:	this->swap(__tmp);
        -:  592:	return *this;
        -:  593:      }
        -:  594:
        -:  595:      /**
        -:  596:       * @brief The move-assignment operator.
        -:  597:       *
        -:  598:       * @param __rhs Another regular expression object.
        -:  599:       */
        -:  600:      basic_regex&
        -:  601:      assign(basic_regex&& __rhs) noexcept
        -:  602:      {
        -:  603:	basic_regex __tmp(std::move(__rhs));
        -:  604:	this->swap(__tmp);
        -:  605:	return *this;
        -:  606:      }
        -:  607:
        -:  608:      /**
        -:  609:       * @brief Assigns a new regular expression to a regex object from a
        -:  610:       * C-style null-terminated string containing a regular expression
        -:  611:       * pattern.
        -:  612:       *
        -:  613:       * @param __p     A pointer to a C-style null-terminated string containing
        -:  614:       *              a regular expression pattern.
        -:  615:       * @param __flags Syntax option flags.
        -:  616:       *
        -:  617:       * @throws regex_error if __p does not contain a valid regular
        -:  618:       * expression pattern interpreted according to @p __flags.  If
        -:  619:       * regex_error is thrown, *this remains unchanged.
        -:  620:       */
        -:  621:      basic_regex&
        -:  622:      assign(const _Ch_type* __p, flag_type __flags = ECMAScript)
        -:  623:      { return this->assign(string_type(__p), __flags); }
        -:  624:
        -:  625:      /**
        -:  626:       * @brief Assigns a new regular expression to a regex object from a
        -:  627:       * C-style string containing a regular expression pattern.
        -:  628:       *
        -:  629:       * @param __p     A pointer to a C-style string containing a
        -:  630:       *                regular expression pattern.
        -:  631:       * @param __len   The length of the regular expression pattern string.
        -:  632:       * @param __flags Syntax option flags.
        -:  633:       *
        -:  634:       * @throws regex_error if p does not contain a valid regular
        -:  635:       * expression pattern interpreted according to @p __flags.  If
        -:  636:       * regex_error is thrown, *this remains unchanged.
        -:  637:       */
        -:  638:      basic_regex&
        -:  639:      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)
        -:  640:      { return this->assign(string_type(__p, __len), __flags); }
        -:  641:
        -:  642:      /**
        -:  643:       * @brief Assigns a new regular expression to a regex object from a
        -:  644:       * string containing a regular expression pattern.
        -:  645:       *
        -:  646:       * @param __s     A string containing a regular expression pattern.
        -:  647:       * @param __flags Syntax option flags.
        -:  648:       *
        -:  649:       * @throws regex_error if __s does not contain a valid regular
        -:  650:       * expression pattern interpreted according to @p __flags.  If
        -:  651:       * regex_error is thrown, *this remains unchanged.
        -:  652:       */
        -:  653:      template<typename _Ch_traits, typename _Alloc>
        -:  654:	basic_regex&
        -:  655:	assign(const basic_string<_Ch_type, _Ch_traits, _Alloc>& __s,
        -:  656:	       flag_type __flags = ECMAScript)
        -:  657:	{
        -:  658:	  return this->assign(basic_regex(__s.data(), __s.data() + __s.size(),
        -:  659:					  _M_loc, __flags));
        -:  660:	}
        -:  661:
        -:  662:      /**
        -:  663:       * @brief Assigns a new regular expression to a regex object.
        -:  664:       *
        -:  665:       * @param __first The start of a range containing a valid regular
        -:  666:       *                expression.
        -:  667:       * @param __last  The end of a range containing a valid regular
        -:  668:       *                expression.
        -:  669:       * @param __flags Syntax option flags.
        -:  670:       *
        -:  671:       * @throws regex_error if p does not contain a valid regular
        -:  672:       * expression pattern interpreted according to @p __flags.  If
        -:  673:       * regex_error is thrown, the object remains unchanged.
        -:  674:       */
        -:  675:      template<typename _InputIterator>
        -:  676:	basic_regex&
        -:  677:	assign(_InputIterator __first, _InputIterator __last,
        -:  678:	       flag_type __flags = ECMAScript)
        -:  679:	{ return this->assign(string_type(__first, __last), __flags); }
        -:  680:
        -:  681:      /**
        -:  682:       * @brief Assigns a new regular expression to a regex object.
        -:  683:       *
        -:  684:       * @param __l     An initializer list representing a regular expression.
        -:  685:       * @param __flags Syntax option flags.
        -:  686:       *
        -:  687:       * @throws regex_error if @p __l does not contain a valid
        -:  688:       * regular expression pattern interpreted according to @p
        -:  689:       * __flags.  If regex_error is thrown, the object remains
        -:  690:       * unchanged.
        -:  691:       */
        -:  692:      basic_regex&
        -:  693:      assign(initializer_list<_Ch_type> __l, flag_type __flags = ECMAScript)
        -:  694:      { return this->assign(__l.begin(), __l.end(), __flags); }
        -:  695:
        -:  696:      // [7.8.4] const operations
        -:  697:      /**
        -:  698:       * @brief Gets the number of marked subexpressions within the regular
        -:  699:       * expression.
        -:  700:       */
        -:  701:      unsigned int
        -:  702:      mark_count() const
        -:  703:      {
        -:  704:	if (_M_automaton)
        -:  705:	  return _M_automaton->_M_sub_count() - 1;
        -:  706:	return 0;
        -:  707:      }
        -:  708:
        -:  709:      /**
        -:  710:       * @brief Gets the flags used to construct the regular expression
        -:  711:       * or in the last call to assign().
        -:  712:       */
        -:  713:      flag_type
        -:  714:      flags() const
        -:  715:      { return _M_flags; }
        -:  716:
        -:  717:      // [7.8.5] locale
        -:  718:      /**
        -:  719:       * @brief Imbues the regular expression object with the given locale.
        -:  720:       *
        -:  721:       * @param __loc A locale.
        -:  722:       */
        -:  723:      locale_type
        -:  724:      imbue(locale_type __loc)
        -:  725:      {
        -:  726:	std::swap(__loc, _M_loc);
        -:  727:	_M_automaton.reset();
        -:  728:	return __loc;
        -:  729:      }
        -:  730:
        -:  731:      /**
        -:  732:       * @brief Gets the locale currently imbued in the regular expression
        -:  733:       *        object.
        -:  734:       */
        -:  735:      locale_type
        -:  736:      getloc() const
        -:  737:      { return _M_loc; }
        -:  738:
        -:  739:      // [7.8.6] swap
        -:  740:      /**
        -:  741:       * @brief Swaps the contents of two regular expression objects.
        -:  742:       *
        -:  743:       * @param __rhs Another regular expression object.
        -:  744:       */
        -:  745:      void
        -:  746:      swap(basic_regex& __rhs)
        -:  747:      {
        -:  748:	std::swap(_M_flags, __rhs._M_flags);
        -:  749:	std::swap(_M_loc, __rhs._M_loc);
        -:  750:	std::swap(_M_automaton, __rhs._M_automaton);
        -:  751:      }
        -:  752:
        -:  753:#ifdef _GLIBCXX_DEBUG
        -:  754:      void
        -:  755:      _M_dot(std::ostream& __ostr)
        -:  756:      { _M_automaton->_M_dot(__ostr); }
        -:  757:#endif
        -:  758:
        -:  759:    private:
        -:  760:      typedef std::shared_ptr<const __detail::_NFA<_Rx_traits>> _AutomatonPtr;
        -:  761:
        -:  762:      template<typename _FwdIter>
function _ZNSt7__cxx1111basic_regexIcNS_12regex_traitsIcEEEC2IPKcEET_S7_St6localeNSt15regex_constants18syntax_option_typeE called 0 returned 0% blocks executed 0%
    #####:  763:	basic_regex(_FwdIter __first, _FwdIter __last, locale_type __loc,
        -:  764:		    flag_type __f)
    #####:  765:	: _M_flags(__f), _M_loc(std::move(__loc)),
call    0 never executed
        -:  766:	_M_automaton(__detail::__compile_nfa<_FwdIter, _Rx_traits>(
    #####:  767:	  std::move(__first), std::move(__last), _M_loc, _M_flags))
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  768:	{ }
        -:  769:
        -:  770:      template<typename _Bp, typename _Ap, typename _Cp, typename _Rp,
        -:  771:	__detail::_RegexExecutorPolicy, bool>
        -:  772:	friend bool
        -:  773:	__detail::__regex_algo_impl(_Bp, _Bp, match_results<_Bp, _Ap>&,
        -:  774:				    const basic_regex<_Cp, _Rp>&,
        -:  775:				    regex_constants::match_flag_type);
        -:  776:
        -:  777:      template<typename, typename, typename, bool>
        -:  778:	friend class __detail::_Executor;
        -:  779:
        -:  780:      flag_type              _M_flags;
        -:  781:      locale_type            _M_loc;
        -:  782:      _AutomatonPtr          _M_automaton;
        -:  783:    };
        -:  784:
        -:  785:  /** @brief Standard regular expressions. */
        -:  786:  typedef basic_regex<char>    regex;
        -:  787:
        -:  788:#ifdef _GLIBCXX_USE_WCHAR_T
        -:  789:  /** @brief Standard wide-character regular expressions. */
        -:  790:  typedef basic_regex<wchar_t> wregex;
        -:  791:#endif
        -:  792:
        -:  793:
        -:  794:  // [7.8.6] basic_regex swap
        -:  795:  /**
        -:  796:   * @brief Swaps the contents of two regular expression objects.
        -:  797:   * @param __lhs First regular expression.
        -:  798:   * @param __rhs Second regular expression.
        -:  799:   */
        -:  800:  template<typename _Ch_type, typename _Rx_traits>
        -:  801:    inline void
        -:  802:    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,
        -:  803:	 basic_regex<_Ch_type, _Rx_traits>& __rhs)
        -:  804:    { __lhs.swap(__rhs); }
        -:  805:
        -:  806:
        -:  807:  // [7.9] Class template sub_match
        -:  808:  /**
        -:  809:   * A sequence of characters matched by a particular marked sub-expression.
        -:  810:   *
        -:  811:   * An object of this class is essentially a pair of iterators marking a
        -:  812:   * matched subexpression within a regular expression pattern match. Such
        -:  813:   * objects can be converted to and compared with std::basic_string objects
        -:  814:   * of a similar base character type as the pattern matched by the regular
        -:  815:   * expression.
        -:  816:   *
        -:  817:   * The iterators that make up the pair are the usual half-open interval
        -:  818:   * referencing the actual original pattern matched.
        -:  819:   */
        -:  820:  template<typename _BiIter>
function _ZNSt7__cxx119sub_matchIN9__gnu_cxx17__normal_iteratorIPKcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEEEaSERKSB_ called 0 returned 0% blocks executed 0%
    #####:  821:    class sub_match : public std::pair<_BiIter, _BiIter>
call    0 never executed
        -:  822:    {
        -:  823:      typedef iterator_traits<_BiIter>			__iter_traits;
        -:  824:	
        -:  825:    public:
        -:  826:      typedef typename __iter_traits::value_type      	value_type;
        -:  827:      typedef typename __iter_traits::difference_type 	difference_type;
        -:  828:      typedef _BiIter                                   iterator;
        -:  829:      typedef std::basic_string<value_type>             string_type;
        -:  830:
        -:  831:      bool matched;
        -:  832:
function _ZNSt7__cxx119sub_matchIN9__gnu_cxx17__normal_iteratorIPKcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEEEC2Ev called 0 returned 0% blocks executed 0%
    #####:  833:      constexpr sub_match() : matched() { }
call    0 never executed
        -:  834:
        -:  835:      /**
        -:  836:       * Gets the length of the matching sequence.
        -:  837:       */
        -:  838:      difference_type
        -:  839:      length() const
        -:  840:      { return this->matched ? std::distance(this->first, this->second) : 0; }
        -:  841:
        -:  842:      /**
        -:  843:       * @brief Gets the matching sequence as a string.
        -:  844:       *
        -:  845:       * @returns the matching sequence as a string.
        -:  846:       *
        -:  847:       * This is the implicit conversion operator.  It is identical to the
        -:  848:       * str() member function except that it will want to pop up in
        -:  849:       * unexpected places and cause a great deal of confusion and cursing
        -:  850:       * from the unwary.
        -:  851:       */
        -:  852:      operator string_type() const
        -:  853:      {
        -:  854:	return this->matched
        -:  855:	  ? string_type(this->first, this->second)
        -:  856:	  : string_type();
        -:  857:      }
        -:  858:
        -:  859:      /**
        -:  860:       * @brief Gets the matching sequence as a string.
        -:  861:       *
        -:  862:       * @returns the matching sequence as a string.
        -:  863:       */
        -:  864:      string_type
        -:  865:      str() const
        -:  866:      {
        -:  867:	return this->matched
        -:  868:	  ? string_type(this->first, this->second)
        -:  869:	  : string_type();
        -:  870:      }
        -:  871:
        -:  872:      /**
        -:  873:       * @brief Compares this and another matched sequence.
        -:  874:       *
        -:  875:       * @param __s Another matched sequence to compare to this one.
        -:  876:       *
        -:  877:       * @retval <0 this matched sequence will collate before @p __s.
        -:  878:       * @retval =0 this matched sequence is equivalent to @p __s.
        -:  879:       * @retval <0 this matched sequence will collate after @p __s.
        -:  880:       */
        -:  881:      int
        -:  882:      compare(const sub_match& __s) const
        -:  883:      { return this->str().compare(__s.str()); }
        -:  884:
        -:  885:      /**
        -:  886:       * @brief Compares this sub_match to a string.
        -:  887:       *
        -:  888:       * @param __s A string to compare to this sub_match.
        -:  889:       *
        -:  890:       * @retval <0 this matched sequence will collate before @p __s.
        -:  891:       * @retval =0 this matched sequence is equivalent to @p __s.
        -:  892:       * @retval <0 this matched sequence will collate after @p __s.
        -:  893:       */
        -:  894:      int
        -:  895:      compare(const string_type& __s) const
        -:  896:      { return this->str().compare(__s); }
        -:  897:
        -:  898:      /**
        -:  899:       * @brief Compares this sub_match to a C-style string.
        -:  900:       *
        -:  901:       * @param __s A C-style string to compare to this sub_match.
        -:  902:       *
        -:  903:       * @retval <0 this matched sequence will collate before @p __s.
        -:  904:       * @retval =0 this matched sequence is equivalent to @p __s.
        -:  905:       * @retval <0 this matched sequence will collate after @p __s.
        -:  906:       */
        -:  907:      int
        -:  908:      compare(const value_type* __s) const
        -:  909:      { return this->str().compare(__s); }
        -:  910:    };
        -:  911:
        -:  912:
        -:  913:  /** @brief Standard regex submatch over a C-style null-terminated string. */
        -:  914:  typedef sub_match<const char*>             csub_match;
        -:  915:
        -:  916:  /** @brief Standard regex submatch over a standard string. */
        -:  917:  typedef sub_match<string::const_iterator>  ssub_match;
        -:  918:
        -:  919:#ifdef _GLIBCXX_USE_WCHAR_T
        -:  920:  /** @brief Regex submatch over a C-style null-terminated wide string. */
        -:  921:  typedef sub_match<const wchar_t*>          wcsub_match;
        -:  922:
        -:  923:  /** @brief Regex submatch over a standard wide string. */
        -:  924:  typedef sub_match<wstring::const_iterator> wssub_match;
        -:  925:#endif
        -:  926:
        -:  927:  // [7.9.2] sub_match non-member operators
        -:  928:
        -:  929:  /**
        -:  930:   * @brief Tests the equivalence of two regular expression submatches.
        -:  931:   * @param __lhs First regular expression submatch.
        -:  932:   * @param __rhs Second regular expression submatch.
        -:  933:   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
        -:  934:   */
        -:  935:  template<typename _BiIter>
        -:  936:    inline bool
        -:  937:    operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
        -:  938:    { return __lhs.compare(__rhs) == 0; }
        -:  939:
        -:  940:  /**
        -:  941:   * @brief Tests the inequivalence of two regular expression submatches.
        -:  942:   * @param __lhs First regular expression submatch.
        -:  943:   * @param __rhs Second regular expression submatch.
        -:  944:   * @returns true if @a __lhs  is not equivalent to @a __rhs, false otherwise.
        -:  945:   */
        -:  946:  template<typename _BiIter>
        -:  947:    inline bool
        -:  948:    operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
        -:  949:    { return __lhs.compare(__rhs) != 0; }
        -:  950:
        -:  951:  /**
        -:  952:   * @brief Tests the ordering of two regular expression submatches.
        -:  953:   * @param __lhs First regular expression submatch.
        -:  954:   * @param __rhs Second regular expression submatch.
        -:  955:   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
        -:  956:   */
        -:  957:  template<typename _BiIter>
        -:  958:    inline bool
        -:  959:    operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
        -:  960:    { return __lhs.compare(__rhs) < 0; }
        -:  961:
        -:  962:  /**
        -:  963:   * @brief Tests the ordering of two regular expression submatches.
        -:  964:   * @param __lhs First regular expression submatch.
        -:  965:   * @param __rhs Second regular expression submatch.
        -:  966:   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
        -:  967:   */
        -:  968:  template<typename _BiIter>
        -:  969:    inline bool
        -:  970:    operator<=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
        -:  971:    { return __lhs.compare(__rhs) <= 0; }
        -:  972:
        -:  973:  /**
        -:  974:   * @brief Tests the ordering of two regular expression submatches.
        -:  975:   * @param __lhs First regular expression submatch.
        -:  976:   * @param __rhs Second regular expression submatch.
        -:  977:   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
        -:  978:   */
        -:  979:  template<typename _BiIter>
        -:  980:    inline bool
        -:  981:    operator>=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
        -:  982:    { return __lhs.compare(__rhs) >= 0; }
        -:  983:
        -:  984:  /**
        -:  985:   * @brief Tests the ordering of two regular expression submatches.
        -:  986:   * @param __lhs First regular expression submatch.
        -:  987:   * @param __rhs Second regular expression submatch.
        -:  988:   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
        -:  989:   */
        -:  990:  template<typename _BiIter>
        -:  991:    inline bool
        -:  992:    operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
        -:  993:    { return __lhs.compare(__rhs) > 0; }
        -:  994:
        -:  995:  // Alias for sub_match'd string.
        -:  996:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -:  997:    using __sub_match_string = basic_string<
        -:  998:			      typename iterator_traits<_Bi_iter>::value_type,
        -:  999:			      _Ch_traits, _Ch_alloc>;
        -: 1000:
        -: 1001:  /**
        -: 1002:   * @brief Tests the equivalence of a string and a regular expression
        -: 1003:   *        submatch.
        -: 1004:   * @param __lhs A string.
        -: 1005:   * @param __rhs A regular expression submatch.
        -: 1006:   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
        -: 1007:   */
        -: 1008:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -: 1009:    inline bool
        -: 1010:    operator==(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
        -: 1011:	       const sub_match<_Bi_iter>& __rhs)
        -: 1012:    {
        -: 1013:      typedef typename sub_match<_Bi_iter>::string_type string_type;
        -: 1014:      return __rhs.compare(string_type(__lhs.data(), __lhs.size())) == 0;
        -: 1015:    }
        -: 1016:
        -: 1017:  /**
        -: 1018:   * @brief Tests the inequivalence of a string and a regular expression
        -: 1019:   *        submatch.
        -: 1020:   * @param __lhs A string.
        -: 1021:   * @param __rhs A regular expression submatch.
        -: 1022:   * @returns true if @a __lhs  is not equivalent to @a __rhs, false otherwise.
        -: 1023:   */
        -: 1024:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -: 1025:    inline bool
        -: 1026:    operator!=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
        -: 1027:	       const sub_match<_Bi_iter>& __rhs)
        -: 1028:    { return !(__lhs == __rhs); }
        -: 1029:
        -: 1030:  /**
        -: 1031:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1032:   * @param __lhs A string.
        -: 1033:   * @param __rhs A regular expression submatch.
        -: 1034:   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
        -: 1035:   */
        -: 1036:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -: 1037:    inline bool
        -: 1038:    operator<(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
        -: 1039:	      const sub_match<_Bi_iter>& __rhs)
        -: 1040:    {
        -: 1041:      typedef typename sub_match<_Bi_iter>::string_type string_type;
        -: 1042:      return __rhs.compare(string_type(__lhs.data(), __lhs.size())) > 0;
        -: 1043:    }
        -: 1044:
        -: 1045:  /**
        -: 1046:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1047:   * @param __lhs A string.
        -: 1048:   * @param __rhs A regular expression submatch.
        -: 1049:   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
        -: 1050:   */
        -: 1051:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -: 1052:    inline bool
        -: 1053:    operator>(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
        -: 1054:	      const sub_match<_Bi_iter>& __rhs)
        -: 1055:    { return __rhs < __lhs; }
        -: 1056:
        -: 1057:  /**
        -: 1058:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1059:   * @param __lhs A string.
        -: 1060:   * @param __rhs A regular expression submatch.
        -: 1061:   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
        -: 1062:   */
        -: 1063:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -: 1064:    inline bool
        -: 1065:    operator>=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
        -: 1066:	       const sub_match<_Bi_iter>& __rhs)
        -: 1067:    { return !(__lhs < __rhs); }
        -: 1068:
        -: 1069:  /**
        -: 1070:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1071:   * @param __lhs A string.
        -: 1072:   * @param __rhs A regular expression submatch.
        -: 1073:   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
        -: 1074:   */
        -: 1075:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -: 1076:    inline bool
        -: 1077:    operator<=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
        -: 1078:	       const sub_match<_Bi_iter>& __rhs)
        -: 1079:    { return !(__rhs < __lhs); }
        -: 1080:
        -: 1081:  /**
        -: 1082:   * @brief Tests the equivalence of a regular expression submatch and a
        -: 1083:   *        string.
        -: 1084:   * @param __lhs A regular expression submatch.
        -: 1085:   * @param __rhs A string.
        -: 1086:   * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.
        -: 1087:   */
        -: 1088:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -: 1089:    inline bool
        -: 1090:    operator==(const sub_match<_Bi_iter>& __lhs,
        -: 1091:	       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
        -: 1092:    {
        -: 1093:      typedef typename sub_match<_Bi_iter>::string_type string_type;
        -: 1094:      return __lhs.compare(string_type(__rhs.data(), __rhs.size())) == 0;
        -: 1095:    }
        -: 1096:
        -: 1097:  /**
        -: 1098:   * @brief Tests the inequivalence of a regular expression submatch and a
        -: 1099:   *        string.
        -: 1100:   * @param __lhs A regular expression submatch.
        -: 1101:   * @param __rhs A string.
        -: 1102:   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
        -: 1103:   */
        -: 1104:  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>
        -: 1105:    inline bool
        -: 1106:    operator!=(const sub_match<_Bi_iter>& __lhs,
        -: 1107:	       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
        -: 1108:    { return !(__lhs == __rhs); }
        -: 1109:
        -: 1110:  /**
        -: 1111:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1112:   * @param __lhs A regular expression submatch.
        -: 1113:   * @param __rhs A string.
        -: 1114:   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
        -: 1115:   */
        -: 1116:  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
        -: 1117:    inline bool
        -: 1118:    operator<(const sub_match<_Bi_iter>& __lhs,
        -: 1119:	      const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
        -: 1120:    {
        -: 1121:      typedef typename sub_match<_Bi_iter>::string_type string_type;
        -: 1122:      return __lhs.compare(string_type(__rhs.data(), __rhs.size())) < 0;
        -: 1123:    }
        -: 1124:
        -: 1125:  /**
        -: 1126:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1127:   * @param __lhs A regular expression submatch.
        -: 1128:   * @param __rhs A string.
        -: 1129:   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
        -: 1130:   */
        -: 1131:  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
        -: 1132:    inline bool
        -: 1133:    operator>(const sub_match<_Bi_iter>& __lhs,
        -: 1134:	      const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
        -: 1135:    { return __rhs < __lhs; }
        -: 1136:
        -: 1137:  /**
        -: 1138:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1139:   * @param __lhs A regular expression submatch.
        -: 1140:   * @param __rhs A string.
        -: 1141:   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
        -: 1142:   */
        -: 1143:  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
        -: 1144:    inline bool
        -: 1145:    operator>=(const sub_match<_Bi_iter>& __lhs,
        -: 1146:	       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
        -: 1147:    { return !(__lhs < __rhs); }
        -: 1148:
        -: 1149:  /**
        -: 1150:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1151:   * @param __lhs A regular expression submatch.
        -: 1152:   * @param __rhs A string.
        -: 1153:   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
        -: 1154:   */
        -: 1155:  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>
        -: 1156:    inline bool
        -: 1157:    operator<=(const sub_match<_Bi_iter>& __lhs,
        -: 1158:	       const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __rhs)
        -: 1159:    { return !(__rhs < __lhs); }
        -: 1160:
        -: 1161:  /**
        -: 1162:   * @brief Tests the equivalence of a C string and a regular expression
        -: 1163:   *        submatch.
        -: 1164:   * @param __lhs A C string.
        -: 1165:   * @param __rhs A regular expression submatch.
        -: 1166:   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
        -: 1167:   */
        -: 1168:  template<typename _Bi_iter>
        -: 1169:    inline bool
        -: 1170:    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
        -: 1171:	       const sub_match<_Bi_iter>& __rhs)
        -: 1172:    { return __rhs.compare(__lhs) == 0; }
        -: 1173:
        -: 1174:  /**
        -: 1175:   * @brief Tests the inequivalence of an iterator value and a regular
        -: 1176:   *        expression submatch.
        -: 1177:   * @param __lhs A regular expression submatch.
        -: 1178:   * @param __rhs A string.
        -: 1179:   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
        -: 1180:   */
        -: 1181:  template<typename _Bi_iter>
        -: 1182:    inline bool
        -: 1183:    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
        -: 1184:	       const sub_match<_Bi_iter>& __rhs)
        -: 1185:    { return !(__lhs == __rhs); }
        -: 1186:
        -: 1187:  /**
        -: 1188:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1189:   * @param __lhs A string.
        -: 1190:   * @param __rhs A regular expression submatch.
        -: 1191:   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
        -: 1192:   */
        -: 1193:  template<typename _Bi_iter>
        -: 1194:    inline bool
        -: 1195:    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
        -: 1196:	      const sub_match<_Bi_iter>& __rhs)
        -: 1197:    { return __rhs.compare(__lhs) > 0; }
        -: 1198:
        -: 1199:  /**
        -: 1200:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1201:   * @param __lhs A string.
        -: 1202:   * @param __rhs A regular expression submatch.
        -: 1203:   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
        -: 1204:   */
        -: 1205:  template<typename _Bi_iter>
        -: 1206:    inline bool
        -: 1207:    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
        -: 1208:	      const sub_match<_Bi_iter>& __rhs)
        -: 1209:    { return __rhs < __lhs; }
        -: 1210:
        -: 1211:  /**
        -: 1212:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1213:   * @param __lhs A string.
        -: 1214:   * @param __rhs A regular expression submatch.
        -: 1215:   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
        -: 1216:   */
        -: 1217:  template<typename _Bi_iter>
        -: 1218:    inline bool
        -: 1219:    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
        -: 1220:	       const sub_match<_Bi_iter>& __rhs)
        -: 1221:    { return !(__lhs < __rhs); }
        -: 1222:
        -: 1223:  /**
        -: 1224:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1225:   * @param __lhs A string.
        -: 1226:   * @param __rhs A regular expression submatch.
        -: 1227:   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
        -: 1228:   */
        -: 1229:  template<typename _Bi_iter>
        -: 1230:    inline bool
        -: 1231:    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
        -: 1232:	       const sub_match<_Bi_iter>& __rhs)
        -: 1233:    { return !(__rhs < __lhs); }
        -: 1234:
        -: 1235:  /**
        -: 1236:   * @brief Tests the equivalence of a regular expression submatch and a
        -: 1237:   *        string.
        -: 1238:   * @param __lhs A regular expression submatch.
        -: 1239:   * @param __rhs A pointer to a string?
        -: 1240:   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
        -: 1241:   */
        -: 1242:  template<typename _Bi_iter>
        -: 1243:    inline bool
        -: 1244:    operator==(const sub_match<_Bi_iter>& __lhs,
        -: 1245:	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
        -: 1246:    { return __lhs.compare(__rhs) == 0; }
        -: 1247:
        -: 1248:  /**
        -: 1249:   * @brief Tests the inequivalence of a regular expression submatch and a
        -: 1250:   *        string.
        -: 1251:   * @param __lhs A regular expression submatch.
        -: 1252:   * @param __rhs A pointer to a string.
        -: 1253:   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
        -: 1254:   */
        -: 1255:  template<typename _Bi_iter>
        -: 1256:    inline bool
        -: 1257:    operator!=(const sub_match<_Bi_iter>& __lhs,
        -: 1258:	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
        -: 1259:    { return !(__lhs == __rhs); }
        -: 1260:
        -: 1261:  /**
        -: 1262:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1263:   * @param __lhs A regular expression submatch.
        -: 1264:   * @param __rhs A string.
        -: 1265:   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
        -: 1266:   */
        -: 1267:  template<typename _Bi_iter>
        -: 1268:    inline bool
        -: 1269:    operator<(const sub_match<_Bi_iter>& __lhs,
        -: 1270:	      typename iterator_traits<_Bi_iter>::value_type const* __rhs)
        -: 1271:    { return __lhs.compare(__rhs) < 0; }
        -: 1272:
        -: 1273:  /**
        -: 1274:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1275:   * @param __lhs A regular expression submatch.
        -: 1276:   * @param __rhs A string.
        -: 1277:   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
        -: 1278:   */
        -: 1279:  template<typename _Bi_iter>
        -: 1280:    inline bool
        -: 1281:    operator>(const sub_match<_Bi_iter>& __lhs,
        -: 1282:	      typename iterator_traits<_Bi_iter>::value_type const* __rhs)
        -: 1283:    { return __rhs < __lhs; }
        -: 1284:
        -: 1285:  /**
        -: 1286:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1287:   * @param __lhs A regular expression submatch.
        -: 1288:   * @param __rhs A string.
        -: 1289:   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
        -: 1290:   */
        -: 1291:  template<typename _Bi_iter>
        -: 1292:    inline bool
        -: 1293:    operator>=(const sub_match<_Bi_iter>& __lhs,
        -: 1294:	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
        -: 1295:    { return !(__lhs < __rhs); }
        -: 1296:
        -: 1297:  /**
        -: 1298:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1299:   * @param __lhs A regular expression submatch.
        -: 1300:   * @param __rhs A string.
        -: 1301:   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
        -: 1302:   */
        -: 1303:  template<typename _Bi_iter>
        -: 1304:    inline bool
        -: 1305:    operator<=(const sub_match<_Bi_iter>& __lhs,
        -: 1306:	       typename iterator_traits<_Bi_iter>::value_type const* __rhs)
        -: 1307:    { return !(__rhs < __lhs); }
        -: 1308:
        -: 1309:  /**
        -: 1310:   * @brief Tests the equivalence of a string and a regular expression
        -: 1311:   *        submatch.
        -: 1312:   * @param __lhs A string.
        -: 1313:   * @param __rhs A regular expression submatch.
        -: 1314:   * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.
        -: 1315:   */
        -: 1316:  template<typename _Bi_iter>
        -: 1317:    inline bool
        -: 1318:    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
        -: 1319:	       const sub_match<_Bi_iter>& __rhs)
        -: 1320:    {
        -: 1321:      typedef typename sub_match<_Bi_iter>::string_type string_type;
        -: 1322:      return __rhs.compare(string_type(1, __lhs)) == 0;
        -: 1323:    }
        -: 1324:
        -: 1325:  /**
        -: 1326:   * @brief Tests the inequivalence of a string and a regular expression
        -: 1327:   *        submatch.
        -: 1328:   * @param __lhs A string.
        -: 1329:   * @param __rhs A regular expression submatch.
        -: 1330:   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
        -: 1331:   */
        -: 1332:  template<typename _Bi_iter>
        -: 1333:    inline bool
        -: 1334:    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
        -: 1335:	       const sub_match<_Bi_iter>& __rhs)
        -: 1336:    { return !(__lhs == __rhs); }
        -: 1337:
        -: 1338:  /**
        -: 1339:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1340:   * @param __lhs A string.
        -: 1341:   * @param __rhs A regular expression submatch.
        -: 1342:   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
        -: 1343:   */
        -: 1344:  template<typename _Bi_iter>
        -: 1345:    inline bool
        -: 1346:    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
        -: 1347:	      const sub_match<_Bi_iter>& __rhs)
        -: 1348:    {
        -: 1349:      typedef typename sub_match<_Bi_iter>::string_type string_type;
        -: 1350:      return __rhs.compare(string_type(1, __lhs)) > 0;
        -: 1351:    }
        -: 1352:
        -: 1353:  /**
        -: 1354:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1355:   * @param __lhs A string.
        -: 1356:   * @param __rhs A regular expression submatch.
        -: 1357:   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
        -: 1358:   */
        -: 1359:  template<typename _Bi_iter>
        -: 1360:    inline bool
        -: 1361:    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
        -: 1362:	      const sub_match<_Bi_iter>& __rhs)
        -: 1363:    { return __rhs < __lhs; }
        -: 1364:
        -: 1365:  /**
        -: 1366:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1367:   * @param __lhs A string.
        -: 1368:   * @param __rhs A regular expression submatch.
        -: 1369:   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
        -: 1370:   */
        -: 1371:  template<typename _Bi_iter>
        -: 1372:    inline bool
        -: 1373:    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
        -: 1374:	       const sub_match<_Bi_iter>& __rhs)
        -: 1375:    { return !(__lhs < __rhs); }
        -: 1376:
        -: 1377:  /**
        -: 1378:   * @brief Tests the ordering of a string and a regular expression submatch.
        -: 1379:   * @param __lhs A string.
        -: 1380:   * @param __rhs A regular expression submatch.
        -: 1381:   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
        -: 1382:   */
        -: 1383:  template<typename _Bi_iter>
        -: 1384:    inline bool
        -: 1385:    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
        -: 1386:	       const sub_match<_Bi_iter>& __rhs)
        -: 1387:    { return !(__rhs < __lhs); }
        -: 1388:
        -: 1389:  /**
        -: 1390:   * @brief Tests the equivalence of a regular expression submatch and a
        -: 1391:   *        string.
        -: 1392:   * @param __lhs A regular expression submatch.
        -: 1393:   * @param __rhs A const string reference.
        -: 1394:   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
        -: 1395:   */
        -: 1396:  template<typename _Bi_iter>
        -: 1397:    inline bool
        -: 1398:    operator==(const sub_match<_Bi_iter>& __lhs,
        -: 1399:	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
        -: 1400:    {
        -: 1401:      typedef typename sub_match<_Bi_iter>::string_type string_type;
        -: 1402:      return __lhs.compare(string_type(1, __rhs)) == 0;
        -: 1403:    }
        -: 1404:
        -: 1405:  /**
        -: 1406:   * @brief Tests the inequivalence of a regular expression submatch and a
        -: 1407:   *        string.
        -: 1408:   * @param __lhs A regular expression submatch.
        -: 1409:   * @param __rhs A const string reference.
        -: 1410:   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
        -: 1411:   */
        -: 1412:  template<typename _Bi_iter>
        -: 1413:    inline bool
        -: 1414:    operator!=(const sub_match<_Bi_iter>& __lhs,
        -: 1415:	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
        -: 1416:    { return !(__lhs == __rhs); }
        -: 1417:
        -: 1418:  /**
        -: 1419:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1420:   * @param __lhs A regular expression submatch.
        -: 1421:   * @param __rhs A const string reference.
        -: 1422:   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
        -: 1423:   */
        -: 1424:  template<typename _Bi_iter>
        -: 1425:    inline bool
        -: 1426:    operator<(const sub_match<_Bi_iter>& __lhs,
        -: 1427:	      typename iterator_traits<_Bi_iter>::value_type const& __rhs)
        -: 1428:    {
        -: 1429:      typedef typename sub_match<_Bi_iter>::string_type string_type;
        -: 1430:      return __lhs.compare(string_type(1, __rhs)) < 0;
        -: 1431:    }
        -: 1432:
        -: 1433:  /**
        -: 1434:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1435:   * @param __lhs A regular expression submatch.
        -: 1436:   * @param __rhs A const string reference.
        -: 1437:   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
        -: 1438:   */
        -: 1439:  template<typename _Bi_iter>
        -: 1440:    inline bool
        -: 1441:    operator>(const sub_match<_Bi_iter>& __lhs,
        -: 1442:	      typename iterator_traits<_Bi_iter>::value_type const& __rhs)
        -: 1443:    { return __rhs < __lhs; }
        -: 1444:
        -: 1445:  /**
        -: 1446:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1447:   * @param __lhs A regular expression submatch.
        -: 1448:   * @param __rhs A const string reference.
        -: 1449:   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
        -: 1450:   */
        -: 1451:  template<typename _Bi_iter>
        -: 1452:    inline bool
        -: 1453:    operator>=(const sub_match<_Bi_iter>& __lhs,
        -: 1454:	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
        -: 1455:    { return !(__lhs < __rhs); }
        -: 1456:
        -: 1457:  /**
        -: 1458:   * @brief Tests the ordering of a regular expression submatch and a string.
        -: 1459:   * @param __lhs A regular expression submatch.
        -: 1460:   * @param __rhs A const string reference.
        -: 1461:   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
        -: 1462:   */
        -: 1463:  template<typename _Bi_iter>
        -: 1464:    inline bool
        -: 1465:    operator<=(const sub_match<_Bi_iter>& __lhs,
        -: 1466:	       typename iterator_traits<_Bi_iter>::value_type const& __rhs)
        -: 1467:    { return !(__rhs < __lhs); }
        -: 1468:
        -: 1469:  /**
        -: 1470:   * @brief Inserts a matched string into an output stream.
        -: 1471:   *
        -: 1472:   * @param __os The output stream.
        -: 1473:   * @param __m  A submatch string.
        -: 1474:   *
        -: 1475:   * @returns the output stream with the submatch string inserted.
        -: 1476:   */
        -: 1477:  template<typename _Ch_type, typename _Ch_traits, typename _Bi_iter>
        -: 1478:    inline
        -: 1479:    basic_ostream<_Ch_type, _Ch_traits>&
        -: 1480:    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,
        -: 1481:	       const sub_match<_Bi_iter>& __m)
        -: 1482:    { return __os << __m.str(); }
        -: 1483:
        -: 1484:  // [7.10] Class template match_results
        -: 1485:
        -: 1486:  /**
        -: 1487:   * @brief The results of a match or search operation.
        -: 1488:   *
        -: 1489:   * A collection of character sequences representing the result of a regular
        -: 1490:   * expression match.  Storage for the collection is allocated and freed as
        -: 1491:   * necessary by the member functions of class template match_results.
        -: 1492:   *
        -: 1493:   * This class satisfies the Sequence requirements, with the exception that
        -: 1494:   * only the operations defined for a const-qualified Sequence are supported.
        -: 1495:   *
        -: 1496:   * The sub_match object stored at index 0 represents sub-expression 0, i.e.
        -: 1497:   * the whole match. In this case the %sub_match member matched is always true.
        -: 1498:   * The sub_match object stored at index n denotes what matched the marked
        -: 1499:   * sub-expression n within the matched expression. If the sub-expression n
        -: 1500:   * participated in a regular expression match then the %sub_match member
        -: 1501:   * matched evaluates to true, and members first and second denote the range
        -: 1502:   * of characters [first, second) which formed that match. Otherwise matched
        -: 1503:   * is false, and members first and second point to the end of the sequence
        -: 1504:   * that was searched.
        -: 1505:   *
        -: 1506:   * @nosubgrouping
        -: 1507:   */
        -: 1508:  template<typename _Bi_iter,
        -: 1509:	   typename _Alloc = allocator<sub_match<_Bi_iter> > >
        -: 1510:    class match_results
        -: 1511:    : private std::vector<sub_match<_Bi_iter>, _Alloc>
        -: 1512:    {
        -: 1513:    private:
        -: 1514:      /*
        -: 1515:       * The vector base is empty if this does not represent a match (!ready());
        -: 1516:       * Otherwise if it's a match failure, it contains 3 elements:
        -: 1517:       * [0] unmatched
        -: 1518:       * [1] prefix
        -: 1519:       * [2] suffix
        -: 1520:       * Otherwise it contains n+4 elements where n is the number of marked
        -: 1521:       * sub-expressions:
        -: 1522:       * [0] entire match
        -: 1523:       * [1] 1st marked subexpression
        -: 1524:       * ...
        -: 1525:       * [n] nth marked subexpression
        -: 1526:       * [n+1] unmatched
        -: 1527:       * [n+2] prefix
        -: 1528:       * [n+3] suffix
        -: 1529:       */
        -: 1530:      typedef std::vector<sub_match<_Bi_iter>, _Alloc>     _Base_type;
        -: 1531:      typedef std::iterator_traits<_Bi_iter>   	   	   __iter_traits;
        -: 1532:      typedef regex_constants::match_flag_type		   match_flag_type;
        -: 1533:
        -: 1534:    public:
        -: 1535:      /**
        -: 1536:       * @name 10.? Public Types
        -: 1537:       */
        -: 1538:      //@{
        -: 1539:      typedef sub_match<_Bi_iter>                          value_type;
        -: 1540:      typedef const value_type&                            const_reference;
        -: 1541:      typedef const_reference                              reference;
        -: 1542:      typedef typename _Base_type::const_iterator          const_iterator;
        -: 1543:      typedef const_iterator                               iterator;
        -: 1544:      typedef typename __iter_traits::difference_type	   difference_type;
        -: 1545:      typedef typename allocator_traits<_Alloc>::size_type size_type;
        -: 1546:      typedef _Alloc                                       allocator_type;
        -: 1547:      typedef typename __iter_traits::value_type 	   char_type;
        -: 1548:      typedef std::basic_string<char_type>                 string_type;
        -: 1549:      //@}
        -: 1550:
        -: 1551:    public:
        -: 1552:      /**
        -: 1553:       * @name 28.10.1 Construction, Copying, and Destruction
        -: 1554:       */
        -: 1555:      //@{
        -: 1556:
        -: 1557:      /**
        -: 1558:       * @brief Constructs a default %match_results container.
        -: 1559:       * @post size() returns 0 and str() returns an empty string.
        -: 1560:       */
        -: 1561:      explicit
function _ZNSt7__cxx1113match_resultsIN9__gnu_cxx17__normal_iteratorIPKcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEESaINS_9sub_matchISA_EEEEC2ERKSD_ called 0 returned 0% blocks executed 0%
    #####: 1562:      match_results(const _Alloc& __a = _Alloc())
    #####: 1563:      : _Base_type(__a)
call    0 never executed
call    1 never executed
    #####: 1564:      { }
        -: 1565:
        -: 1566:      /**
        -: 1567:       * @brief Copy constructs a %match_results.
        -: 1568:       */
        -: 1569:      match_results(const match_results& __rhs) = default;
        -: 1570:
        -: 1571:      /**
        -: 1572:       * @brief Move constructs a %match_results.
        -: 1573:       */
        -: 1574:      match_results(match_results&& __rhs) noexcept = default;
        -: 1575:
        -: 1576:      /**
        -: 1577:       * @brief Assigns rhs to *this.
        -: 1578:       */
        -: 1579:      match_results&
        -: 1580:      operator=(const match_results& __rhs) = default;
        -: 1581:
        -: 1582:      /**
        -: 1583:       * @brief Move-assigns rhs to *this.
        -: 1584:       */
        -: 1585:      match_results&
        -: 1586:      operator=(match_results&& __rhs) = default;
        -: 1587:
        -: 1588:      /**
        -: 1589:       * @brief Destroys a %match_results object.
        -: 1590:       */
function _ZNSt7__cxx1113match_resultsIN9__gnu_cxx17__normal_iteratorIPKcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEESaINS_9sub_matchISA_EEEED2Ev called 0 returned 0% blocks executed 0%
    #####: 1591:      ~match_results()
    #####: 1592:      { }
call    0 never executed
        -: 1593:
        -: 1594:      //@}
        -: 1595:
        -: 1596:      // 28.10.2, state:
        -: 1597:      /**
        -: 1598:       * @brief Indicates if the %match_results is ready.
        -: 1599:       * @retval true   The object has a fully-established result state.
        -: 1600:       * @retval false  The object is not ready.
        -: 1601:       */
        -: 1602:      bool ready() const { return !_Base_type::empty(); }
        -: 1603:
        -: 1604:      /**
        -: 1605:       * @name 28.10.2 Size
        -: 1606:       */
        -: 1607:      //@{
        -: 1608:
        -: 1609:      /**
        -: 1610:       * @brief Gets the number of matches and submatches.
        -: 1611:       *
        -: 1612:       * The number of matches for a given regular expression will be either 0
        -: 1613:       * if there was no match or mark_count() + 1 if a match was successful.
        -: 1614:       * Some matches may be empty.
        -: 1615:       *
        -: 1616:       * @returns the number of matches found.
        -: 1617:       */
        -: 1618:      size_type
        -: 1619:      size() const
        -: 1620:      { return _Base_type::empty() ? 0 : _Base_type::size() - 3; }
        -: 1621:
        -: 1622:      size_type
        -: 1623:      max_size() const
        -: 1624:      { return _Base_type::max_size(); }
        -: 1625:
        -: 1626:      /**
        -: 1627:       * @brief Indicates if the %match_results contains no results.
        -: 1628:       * @retval true The %match_results object is empty.
        -: 1629:       * @retval false The %match_results object is not empty.
        -: 1630:       */
        -: 1631:      bool
        -: 1632:      empty() const
        -: 1633:      { return size() == 0; }
        -: 1634:
        -: 1635:      //@}
        -: 1636:
        -: 1637:      /**
        -: 1638:       * @name 10.3 Element Access
        -: 1639:       */
        -: 1640:      //@{
        -: 1641:
        -: 1642:      /**
        -: 1643:       * @brief Gets the length of the indicated submatch.
        -: 1644:       * @param __sub indicates the submatch.
        -: 1645:       * @pre   ready() == true
        -: 1646:       *
        -: 1647:       * This function returns the length of the indicated submatch, or the
        -: 1648:       * length of the entire match if @p __sub is zero (the default).
        -: 1649:       */
        -: 1650:      difference_type
        -: 1651:      length(size_type __sub = 0) const
        -: 1652:      { return (*this)[__sub].length(); }
        -: 1653:
        -: 1654:      /**
        -: 1655:       * @brief Gets the offset of the beginning of the indicated submatch.
        -: 1656:       * @param __sub indicates the submatch.
        -: 1657:       * @pre   ready() == true
        -: 1658:       *
        -: 1659:       * This function returns the offset from the beginning of the target
        -: 1660:       * sequence to the beginning of the submatch, unless the value of @p __sub
        -: 1661:       * is zero (the default), in which case this function returns the offset
        -: 1662:       * from the beginning of the target sequence to the beginning of the
        -: 1663:       * match.
        -: 1664:       */
        -: 1665:      difference_type
        -: 1666:      position(size_type __sub = 0) const
        -: 1667:      { return std::distance(_M_begin, (*this)[__sub].first); }
        -: 1668:
        -: 1669:      /**
        -: 1670:       * @brief Gets the match or submatch converted to a string type.
        -: 1671:       * @param __sub indicates the submatch.
        -: 1672:       * @pre   ready() == true
        -: 1673:       *
        -: 1674:       * This function gets the submatch (or match, if @p __sub is
        -: 1675:       * zero) extracted from the target range and converted to the
        -: 1676:       * associated string type.
        -: 1677:       */
        -: 1678:      string_type
        -: 1679:      str(size_type __sub = 0) const
        -: 1680:      { return string_type((*this)[__sub]); }
        -: 1681:
        -: 1682:      /**
        -: 1683:       * @brief Gets a %sub_match reference for the match or submatch.
        -: 1684:       * @param __sub indicates the submatch.
        -: 1685:       * @pre   ready() == true
        -: 1686:       *
        -: 1687:       * This function gets a reference to the indicated submatch, or
        -: 1688:       * the entire match if @p __sub is zero.
        -: 1689:       *
        -: 1690:       * If @p __sub >= size() then this function returns a %sub_match with a
        -: 1691:       * special value indicating no submatch.
        -: 1692:       */
        -: 1693:      const_reference
        -: 1694:      operator[](size_type __sub) const
        -: 1695:      {
        -: 1696:	_GLIBCXX_DEBUG_ASSERT( ready() );
        -: 1697:	return __sub < size()
        -: 1698:	       ? _Base_type::operator[](__sub)
        -: 1699:	       : _M_unmatched_sub();
        -: 1700:      }
        -: 1701:
        -: 1702:      /**
        -: 1703:       * @brief Gets a %sub_match representing the match prefix.
        -: 1704:       * @pre   ready() == true
        -: 1705:       *
        -: 1706:       * This function gets a reference to a %sub_match object representing the
        -: 1707:       * part of the target range between the start of the target range and the
        -: 1708:       * start of the match.
        -: 1709:       */
        -: 1710:      const_reference
        -: 1711:      prefix() const
        -: 1712:      {
        -: 1713:	_GLIBCXX_DEBUG_ASSERT( ready() );
        -: 1714:	return !empty() ? _M_prefix() : _M_unmatched_sub();
        -: 1715:      }
        -: 1716:
        -: 1717:      /**
        -: 1718:       * @brief Gets a %sub_match representing the match suffix.
        -: 1719:       * @pre   ready() == true
        -: 1720:       *
        -: 1721:       * This function gets a reference to a %sub_match object representing the
        -: 1722:       * part of the target range between the end of the match and the end of
        -: 1723:       * the target range.
        -: 1724:       */
        -: 1725:      const_reference
        -: 1726:      suffix() const
        -: 1727:      {
        -: 1728:	_GLIBCXX_DEBUG_ASSERT( ready() );
        -: 1729:	return !empty() ? _M_suffix() : _M_unmatched_sub();
        -: 1730:      }
        -: 1731:
        -: 1732:      /**
        -: 1733:       * @brief Gets an iterator to the start of the %sub_match collection.
        -: 1734:       */
        -: 1735:      const_iterator
        -: 1736:      begin() const
        -: 1737:      { return _Base_type::begin(); }
        -: 1738:
        -: 1739:      /**
        -: 1740:       * @brief Gets an iterator to the start of the %sub_match collection.
        -: 1741:       */
        -: 1742:      const_iterator
        -: 1743:      cbegin() const
        -: 1744:      { return this->begin(); }
        -: 1745:
        -: 1746:      /**
        -: 1747:       * @brief Gets an iterator to one-past-the-end of the collection.
        -: 1748:       */
        -: 1749:      const_iterator
        -: 1750:      end() const
        -: 1751:      { return _Base_type::end() - 3; }
        -: 1752:
        -: 1753:      /**
        -: 1754:       * @brief Gets an iterator to one-past-the-end of the collection.
        -: 1755:       */
        -: 1756:      const_iterator
        -: 1757:      cend() const
        -: 1758:      { return this->end(); }
        -: 1759:
        -: 1760:      //@}
        -: 1761:
        -: 1762:      /**
        -: 1763:       * @name 10.4 Formatting
        -: 1764:       *
        -: 1765:       * These functions perform formatted substitution of the matched
        -: 1766:       * character sequences into their target.  The format specifiers and
        -: 1767:       * escape sequences accepted by these functions are determined by
        -: 1768:       * their @p flags parameter as documented above.
        -: 1769:       */
        -: 1770:       //@{
        -: 1771:
        -: 1772:      /**
        -: 1773:       * @pre   ready() == true
        -: 1774:       */
        -: 1775:      template<typename _Out_iter>
        -: 1776:	_Out_iter
        -: 1777:	format(_Out_iter __out, const char_type* __fmt_first,
        -: 1778:	       const char_type* __fmt_last,
        -: 1779:	       match_flag_type __flags = regex_constants::format_default) const;
        -: 1780:
        -: 1781:      /**
        -: 1782:       * @pre   ready() == true
        -: 1783:       */
        -: 1784:      template<typename _Out_iter, typename _St, typename _Sa>
        -: 1785:	_Out_iter
        -: 1786:	format(_Out_iter __out, const basic_string<char_type, _St, _Sa>& __fmt,
        -: 1787:	       match_flag_type __flags = regex_constants::format_default) const
        -: 1788:	{
        -: 1789:	  return format(__out, __fmt.data(), __fmt.data() + __fmt.size(),
        -: 1790:			__flags);
        -: 1791:	}
        -: 1792:
        -: 1793:      /**
        -: 1794:       * @pre   ready() == true
        -: 1795:       */
        -: 1796:      template<typename _St, typename _Sa>
        -: 1797:	basic_string<char_type, _St, _Sa>
        -: 1798:	format(const basic_string<char_type, _St, _Sa>& __fmt,
        -: 1799:	       match_flag_type __flags = regex_constants::format_default) const
        -: 1800:	{
        -: 1801:	  basic_string<char_type, _St, _Sa> __result;
        -: 1802:	  format(std::back_inserter(__result), __fmt, __flags);
        -: 1803:	  return __result;
        -: 1804:	}
        -: 1805:
        -: 1806:      /**
        -: 1807:       * @pre   ready() == true
        -: 1808:       */
        -: 1809:      string_type
        -: 1810:      format(const char_type* __fmt,
        -: 1811:	     match_flag_type __flags = regex_constants::format_default) const
        -: 1812:      {
        -: 1813:	string_type __result;
        -: 1814:	format(std::back_inserter(__result),
        -: 1815:	       __fmt,
        -: 1816:	       __fmt + char_traits<char_type>::length(__fmt),
        -: 1817:	       __flags);
        -: 1818:	return __result;
        -: 1819:      }
        -: 1820:
        -: 1821:      //@}
        -: 1822:
        -: 1823:      /**
        -: 1824:       * @name 10.5 Allocator
        -: 1825:       */
        -: 1826:      //@{
        -: 1827:
        -: 1828:      /**
        -: 1829:       * @brief Gets a copy of the allocator.
        -: 1830:       */
        -: 1831:      allocator_type
        -: 1832:      get_allocator() const
        -: 1833:      { return _Base_type::get_allocator(); }
        -: 1834:
        -: 1835:      //@}
        -: 1836:
        -: 1837:      /**
        -: 1838:       * @name 10.6 Swap
        -: 1839:       */
        -: 1840:       //@{
        -: 1841:
        -: 1842:      /**
        -: 1843:       * @brief Swaps the contents of two match_results.
        -: 1844:       */
        -: 1845:      void
        -: 1846:      swap(match_results& __that)
        -: 1847:      {
        -: 1848:	using std::swap;
        -: 1849:	_Base_type::swap(__that);
        -: 1850:	swap(_M_begin, __that._M_begin);
        -: 1851:      }
        -: 1852:      //@}
        -: 1853:
        -: 1854:    private:
        -: 1855:      template<typename, typename, typename, bool>
        -: 1856:	friend class __detail::_Executor;
        -: 1857:
        -: 1858:      template<typename, typename, typename>
        -: 1859:	friend class regex_iterator;
        -: 1860:
        -: 1861:      template<typename _Bp, typename _Ap, typename _Cp, typename _Rp,
        -: 1862:	__detail::_RegexExecutorPolicy, bool>
        -: 1863:	friend bool
        -: 1864:	__detail::__regex_algo_impl(_Bp, _Bp, match_results<_Bp, _Ap>&,
        -: 1865:				    const basic_regex<_Cp, _Rp>&,
        -: 1866:				    regex_constants::match_flag_type);
        -: 1867:
        -: 1868:      void
function _ZNSt7__cxx1113match_resultsIN9__gnu_cxx17__normal_iteratorIPKcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEESaINS_9sub_matchISA_EEEE9_M_resizeEj called 0 returned 0% blocks executed 0%
    #####: 1869:      _M_resize(unsigned int __size)
    #####: 1870:      { _Base_type::resize(__size + 3); }
call    0 never executed
        -: 1871:
        -: 1872:      const_reference
        -: 1873:      _M_unmatched_sub() const
        -: 1874:      { return _Base_type::operator[](_Base_type::size() - 3); }
        -: 1875:
        -: 1876:      sub_match<_Bi_iter>&
        -: 1877:      _M_unmatched_sub()
        -: 1878:      { return _Base_type::operator[](_Base_type::size() - 3); }
        -: 1879:
        -: 1880:      const_reference
        -: 1881:      _M_prefix() const
        -: 1882:      { return _Base_type::operator[](_Base_type::size() - 2); }
        -: 1883:
        -: 1884:      sub_match<_Bi_iter>&
function _ZNSt7__cxx1113match_resultsIN9__gnu_cxx17__normal_iteratorIPKcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEESaINS_9sub_matchISA_EEEE9_M_prefixEv called 0 returned 0% blocks executed 0%
    #####: 1885:      _M_prefix()
    #####: 1886:      { return _Base_type::operator[](_Base_type::size() - 2); }
call    0 never executed
call    1 never executed
        -: 1887:
        -: 1888:      const_reference
        -: 1889:      _M_suffix() const
        -: 1890:      { return _Base_type::operator[](_Base_type::size() - 1); }
        -: 1891:
        -: 1892:      sub_match<_Bi_iter>&
function _ZNSt7__cxx1113match_resultsIN9__gnu_cxx17__normal_iteratorIPKcNS_12basic_stringIcSt11char_traitsIcESaIcEEEEESaINS_9sub_matchISA_EEEE9_M_suffixEv called 0 returned 0% blocks executed 0%
    #####: 1893:      _M_suffix()
    #####: 1894:      { return _Base_type::operator[](_Base_type::size() - 1); }
call    0 never executed
call    1 never executed
        -: 1895:
        -: 1896:      _Bi_iter _M_begin;
        -: 1897:    };
        -: 1898:
        -: 1899:  typedef match_results<const char*>             cmatch;
        -: 1900:  typedef match_results<string::const_iterator>  smatch;
        -: 1901:#ifdef _GLIBCXX_USE_WCHAR_T
        -: 1902:  typedef match_results<const wchar_t*>          wcmatch;
        -: 1903:  typedef match_results<wstring::const_iterator> wsmatch;
        -: 1904:#endif
        -: 1905:
        -: 1906:  // match_results comparisons
        -: 1907:  /**
        -: 1908:   * @brief Compares two match_results for equality.
        -: 1909:   * @returns true if the two objects refer to the same match,
        -: 1910:   * false otherwise.
        -: 1911:   */
        -: 1912:  template<typename _Bi_iter, typename _Alloc>
        -: 1913:    inline bool
        -: 1914:    operator==(const match_results<_Bi_iter, _Alloc>& __m1,
        -: 1915:	       const match_results<_Bi_iter, _Alloc>& __m2)
        -: 1916:    {
        -: 1917:      if (__m1.ready() != __m2.ready())
        -: 1918:	return false;
        -: 1919:      if (!__m1.ready())  // both are not ready
        -: 1920:	return true;
        -: 1921:      if (__m1.empty() != __m2.empty())
        -: 1922:	return false;
        -: 1923:      if (__m1.empty())   // both are empty
        -: 1924:	return true;
        -: 1925:      return __m1.prefix() == __m2.prefix()
        -: 1926:	&& __m1.size() == __m2.size()
        -: 1927:	&& std::equal(__m1.begin(), __m1.end(), __m2.begin())
        -: 1928:	&& __m1.suffix() == __m2.suffix();
        -: 1929:    }
        -: 1930:
        -: 1931:  /**
        -: 1932:   * @brief Compares two match_results for inequality.
        -: 1933:   * @returns true if the two objects do not refer to the same match,
        -: 1934:   * false otherwise.
        -: 1935:   */
        -: 1936:  template<typename _Bi_iter, class _Alloc>
        -: 1937:    inline bool
        -: 1938:    operator!=(const match_results<_Bi_iter, _Alloc>& __m1,
        -: 1939:	       const match_results<_Bi_iter, _Alloc>& __m2)
        -: 1940:    { return !(__m1 == __m2); }
        -: 1941:
        -: 1942:  // [7.10.6] match_results swap
        -: 1943:  /**
        -: 1944:   * @brief Swaps two match results.
        -: 1945:   * @param __lhs A match result.
        -: 1946:   * @param __rhs A match result.
        -: 1947:   *
        -: 1948:   * The contents of the two match_results objects are swapped.
        -: 1949:   */
        -: 1950:  template<typename _Bi_iter, typename _Alloc>
        -: 1951:    inline void
        -: 1952:    swap(match_results<_Bi_iter, _Alloc>& __lhs,
        -: 1953:	 match_results<_Bi_iter, _Alloc>& __rhs)
        -: 1954:    { __lhs.swap(__rhs); }
        -: 1955:
        -: 1956:_GLIBCXX_END_NAMESPACE_CXX11
        -: 1957:
        -: 1958:  // [7.11.2] Function template regex_match
        -: 1959:  /**
        -: 1960:   * @name Matching, Searching, and Replacing
        -: 1961:   */
        -: 1962:  //@{
        -: 1963:
        -: 1964:  /**
        -: 1965:   * @brief Determines if there is a match between the regular expression @p e
        -: 1966:   * and all of the character sequence [first, last).
        -: 1967:   *
        -: 1968:   * @param __s     Start of the character sequence to match.
        -: 1969:   * @param __e     One-past-the-end of the character sequence to match.
        -: 1970:   * @param __m     The match results.
        -: 1971:   * @param __re    The regular expression.
        -: 1972:   * @param __flags Controls how the regular expression is matched.
        -: 1973:   *
        -: 1974:   * @retval true  A match exists.
        -: 1975:   * @retval false Otherwise.
        -: 1976:   *
        -: 1977:   * @throws an exception of type regex_error.
        -: 1978:   */
        -: 1979:  template<typename _Bi_iter, typename _Alloc,
        -: 1980:	   typename _Ch_type, typename _Rx_traits>
        -: 1981:    inline bool
function _ZSt11regex_matchIN9__gnu_cxx17__normal_iteratorIPKcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEESaINS4_9sub_matchISA_EEEcNS4_12regex_traitsIcEEEbT_SG_RNS4_13match_resultsISG_T0_EERKNS4_11basic_regexIT1_T2_EENSt15regex_constants15match_flag_typeE called 0 returned 0% blocks executed 0%
    #####: 1982:    regex_match(_Bi_iter                                 __s,
        -: 1983:		_Bi_iter                                 __e,
        -: 1984:		match_results<_Bi_iter, _Alloc>&         __m,
        -: 1985:		const basic_regex<_Ch_type, _Rx_traits>& __re,
        -: 1986:		regex_constants::match_flag_type         __flags
        -: 1987:			       = regex_constants::match_default)
        -: 1988:    {
        -: 1989:      return __detail::__regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits,
        -: 1990:	__detail::_RegexExecutorPolicy::_S_auto, true>
    #####: 1991:	  (__s, __e, __m, __re, __flags);
call    0 never executed
        -: 1992:    }
        -: 1993:
        -: 1994:  /**
        -: 1995:   * @brief Indicates if there is a match between the regular expression @p e
        -: 1996:   * and all of the character sequence [first, last).
        -: 1997:   *
        -: 1998:   * @param __first Beginning of the character sequence to match.
        -: 1999:   * @param __last  One-past-the-end of the character sequence to match.
        -: 2000:   * @param __re    The regular expression.
        -: 2001:   * @param __flags Controls how the regular expression is matched.
        -: 2002:   *
        -: 2003:   * @retval true  A match exists.
        -: 2004:   * @retval false Otherwise.
        -: 2005:   *
        -: 2006:   * @throws an exception of type regex_error.
        -: 2007:   */
        -: 2008:  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>
        -: 2009:    inline bool
function _ZSt11regex_matchIN9__gnu_cxx17__normal_iteratorIPKcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEcNS4_12regex_traitsIcEEEbT_SD_RKNS4_11basic_regexIT0_T1_EENSt15regex_constants15match_flag_typeE called 0 returned 0% blocks executed 0%
    #####: 2010:    regex_match(_Bi_iter __first, _Bi_iter __last,
        -: 2011:		const basic_regex<_Ch_type, _Rx_traits>& __re,
        -: 2012:		regex_constants::match_flag_type __flags
        -: 2013:		= regex_constants::match_default)
        -: 2014:    {
    #####: 2015:      match_results<_Bi_iter> __what;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2016:      return regex_match(__first, __last, __what, __re, __flags);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2017:    }
        -: 2018:
        -: 2019:  /**
        -: 2020:   * @brief Determines if there is a match between the regular expression @p e
        -: 2021:   * and a C-style null-terminated string.
        -: 2022:   *
        -: 2023:   * @param __s  The C-style null-terminated string to match.
        -: 2024:   * @param __m  The match results.
        -: 2025:   * @param __re The regular expression.
        -: 2026:   * @param __f  Controls how the regular expression is matched.
        -: 2027:   *
        -: 2028:   * @retval true  A match exists.
        -: 2029:   * @retval false Otherwise.
        -: 2030:   *
        -: 2031:   * @throws an exception of type regex_error.
        -: 2032:   */
        -: 2033:  template<typename _Ch_type, typename _Alloc, typename _Rx_traits>
        -: 2034:    inline bool
        -: 2035:    regex_match(const _Ch_type* __s,
        -: 2036:		match_results<const _Ch_type*, _Alloc>& __m,
        -: 2037:		const basic_regex<_Ch_type, _Rx_traits>& __re,
        -: 2038:		regex_constants::match_flag_type __f
        -: 2039:		= regex_constants::match_default)
        -: 2040:    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }
        -: 2041:
        -: 2042:  /**
        -: 2043:   * @brief Determines if there is a match between the regular expression @p e
        -: 2044:   * and a string.
        -: 2045:   *
        -: 2046:   * @param __s     The string to match.
        -: 2047:   * @param __m     The match results.
        -: 2048:   * @param __re    The regular expression.
        -: 2049:   * @param __flags Controls how the regular expression is matched.
        -: 2050:   *
        -: 2051:   * @retval true  A match exists.
        -: 2052:   * @retval false Otherwise.
        -: 2053:   *
        -: 2054:   * @throws an exception of type regex_error.
        -: 2055:   */
        -: 2056:  template<typename _Ch_traits, typename _Ch_alloc,
        -: 2057:	   typename _Alloc, typename _Ch_type, typename _Rx_traits>
        -: 2058:    inline bool
        -: 2059:    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,
        -: 2060:		match_results<typename basic_string<_Ch_type,
        -: 2061:		_Ch_traits, _Ch_alloc>::const_iterator, _Alloc>& __m,
        -: 2062:		const basic_regex<_Ch_type, _Rx_traits>& __re,
        -: 2063:		regex_constants::match_flag_type __flags
        -: 2064:		= regex_constants::match_default)
        -: 2065:    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }
        -: 2066:
        -: 2067:  // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 2068:  // 2329. regex_match() with match_results should forbid temporary strings
        -: 2069:  /// Prevent unsafe attempts to get match_results from a temporary string.
        -: 2070:  template<typename _Ch_traits, typename _Ch_alloc,
        -: 2071:	   typename _Alloc, typename _Ch_type, typename _Rx_traits>
        -: 2072:    bool
        -: 2073:    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>&&,
        -: 2074:		match_results<typename basic_string<_Ch_type,
        -: 2075:		_Ch_traits, _Ch_alloc>::const_iterator, _Alloc>&,
        -: 2076:		const basic_regex<_Ch_type, _Rx_traits>&,
        -: 2077:		regex_constants::match_flag_type
        -: 2078:		= regex_constants::match_default) = delete;
        -: 2079:
        -: 2080:  /**
        -: 2081:   * @brief Indicates if there is a match between the regular expression @p e
        -: 2082:   * and a C-style null-terminated string.
        -: 2083:   *
        -: 2084:   * @param __s  The C-style null-terminated string to match.
        -: 2085:   * @param __re The regular expression.
        -: 2086:   * @param __f  Controls how the regular expression is matched.
        -: 2087:   *
        -: 2088:   * @retval true  A match exists.
        -: 2089:   * @retval false Otherwise.
        -: 2090:   *
        -: 2091:   * @throws an exception of type regex_error.
        -: 2092:   */
        -: 2093:  template<typename _Ch_type, class _Rx_traits>
        -: 2094:    inline bool
        -: 2095:    regex_match(const _Ch_type* __s,
        -: 2096:		const basic_regex<_Ch_type, _Rx_traits>& __re,
        -: 2097:		regex_constants::match_flag_type __f
        -: 2098:		= regex_constants::match_default)
        -: 2099:    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }
        -: 2100:
        -: 2101:  /**
        -: 2102:   * @brief Indicates if there is a match between the regular expression @p e
        -: 2103:   * and a string.
        -: 2104:   *
        -: 2105:   * @param __s     [IN] The string to match.
        -: 2106:   * @param __re    [IN] The regular expression.
        -: 2107:   * @param __flags [IN] Controls how the regular expression is matched.
        -: 2108:   *
        -: 2109:   * @retval true  A match exists.
        -: 2110:   * @retval false Otherwise.
        -: 2111:   *
        -: 2112:   * @throws an exception of type regex_error.
        -: 2113:   */
        -: 2114:  template<typename _Ch_traits, typename _Str_allocator,
        -: 2115:	   typename _Ch_type, typename _Rx_traits>
        -: 2116:    inline bool
function _ZSt11regex_matchISt11char_traitsIcESaIcEcNSt7__cxx1112regex_traitsIcEEEbRKNS3_12basic_stringIT1_T_T0_EERKNS3_11basic_regexIS7_T2_EENSt15regex_constants15match_flag_typeE called 0 returned 0% blocks executed 0%
    #####: 2117:    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,
        -: 2118:		const basic_regex<_Ch_type, _Rx_traits>& __re,
        -: 2119:		regex_constants::match_flag_type __flags
        -: 2120:		= regex_constants::match_default)
    #####: 2121:    { return regex_match(__s.begin(), __s.end(), __re, __flags); }
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2122:
        -: 2123:  // [7.11.3] Function template regex_search
        -: 2124:  /**
        -: 2125:   * Searches for a regular expression within a range.
        -: 2126:   * @param __s     [IN]  The start of the string to search.
        -: 2127:   * @param __e     [IN]  One-past-the-end of the string to search.
        -: 2128:   * @param __m     [OUT] The match results.
        -: 2129:   * @param __re    [IN]  The regular expression to search for.
        -: 2130:   * @param __flags [IN]  Search policy flags.
        -: 2131:   * @retval true  A match was found within the string.
        -: 2132:   * @retval false No match was found within the string, the content of %m is
        -: 2133:   *               undefined.
        -: 2134:   *
        -: 2135:   * @throws an exception of type regex_error.
        -: 2136:   */
        -: 2137:  template<typename _Bi_iter, typename _Alloc,
        -: 2138:	   typename _Ch_type, typename _Rx_traits>
        -: 2139:    inline bool
        -: 2140:    regex_search(_Bi_iter __s, _Bi_iter __e,
        -: 2141:		 match_results<_Bi_iter, _Alloc>& __m,
        -: 2142:		 const basic_regex<_Ch_type, _Rx_traits>& __re,
        -: 2143:		 regex_constants::match_flag_type __flags
        -: 2144:		 = regex_constants::match_default)
        -: 2145:    {
        -: 2146:      return __detail::__regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits,
        -: 2147:	__detail::_RegexExecutorPolicy::_S_auto, false>
        -: 2148:	  (__s, __e, __m, __re, __flags);
        -: 2149:    }
        -: 2150:
        -: 2151:  /**
        -: 2152:   * Searches for a regular expression within a range.
        -: 2153:   * @param __first [IN]  The start of the string to search.
        -: 2154:   * @param __last  [IN]  One-past-the-end of the string to search.
        -: 2155:   * @param __re    [IN]  The regular expression to search for.
        -: 2156:   * @param __flags [IN]  Search policy flags.
        -: 2157:   * @retval true  A match was found within the string.
        -: 2158:   * @retval false No match was found within the string.
        -: 2159:   *
        -: 2160:   * @throws an exception of type regex_error.
        -: 2161:   */
        -: 2162:  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>
        -: 2163:    inline bool
        -: 2164:    regex_search(_Bi_iter __first, _Bi_iter __last,
        -: 2165:		 const basic_regex<_Ch_type, _Rx_traits>& __re,
        -: 2166:		 regex_constants::match_flag_type __flags
        -: 2167:		 = regex_constants::match_default)
        -: 2168:    {
        -: 2169:      match_results<_Bi_iter> __what;
        -: 2170:      return regex_search(__first, __last, __what, __re, __flags);
        -: 2171:    }
        -: 2172:
        -: 2173:  /**
        -: 2174:   * @brief Searches for a regular expression within a C-string.
        -: 2175:   * @param __s [IN]  A C-string to search for the regex.
        -: 2176:   * @param __m [OUT] The set of regex matches.
        -: 2177:   * @param __e [IN]  The regex to search for in @p s.
        -: 2178:   * @param __f [IN]  The search flags.
        -: 2179:   * @retval true  A match was found within the string.
        -: 2180:   * @retval false No match was found within the string, the content of %m is
        -: 2181:   *               undefined.
        -: 2182:   *
        -: 2183:   * @throws an exception of type regex_error.
        -: 2184:   */
        -: 2185:  template<typename _Ch_type, class _Alloc, class _Rx_traits>
        -: 2186:    inline bool
        -: 2187:    regex_search(const _Ch_type* __s,
        -: 2188:		 match_results<const _Ch_type*, _Alloc>& __m,
        -: 2189:		 const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2190:		 regex_constants::match_flag_type __f
        -: 2191:		 = regex_constants::match_default)
        -: 2192:    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }
        -: 2193:
        -: 2194:  /**
        -: 2195:   * @brief Searches for a regular expression within a C-string.
        -: 2196:   * @param __s [IN]  The C-string to search.
        -: 2197:   * @param __e [IN]  The regular expression to search for.
        -: 2198:   * @param __f [IN]  Search policy flags.
        -: 2199:   * @retval true  A match was found within the string.
        -: 2200:   * @retval false No match was found within the string.
        -: 2201:   *
        -: 2202:   * @throws an exception of type regex_error.
        -: 2203:   */
        -: 2204:  template<typename _Ch_type, typename _Rx_traits>
        -: 2205:    inline bool
        -: 2206:    regex_search(const _Ch_type* __s,
        -: 2207:		 const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2208:		 regex_constants::match_flag_type __f
        -: 2209:		 = regex_constants::match_default)
        -: 2210:    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }
        -: 2211:
        -: 2212:  /**
        -: 2213:   * @brief Searches for a regular expression within a string.
        -: 2214:   * @param __s     [IN]  The string to search.
        -: 2215:   * @param __e     [IN]  The regular expression to search for.
        -: 2216:   * @param __flags [IN]  Search policy flags.
        -: 2217:   * @retval true  A match was found within the string.
        -: 2218:   * @retval false No match was found within the string.
        -: 2219:   *
        -: 2220:   * @throws an exception of type regex_error.
        -: 2221:   */
        -: 2222:  template<typename _Ch_traits, typename _String_allocator,
        -: 2223:	   typename _Ch_type, typename _Rx_traits>
        -: 2224:    inline bool
        -: 2225:    regex_search(const basic_string<_Ch_type, _Ch_traits,
        -: 2226:		 _String_allocator>& __s,
        -: 2227:		 const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2228:		 regex_constants::match_flag_type __flags
        -: 2229:		 = regex_constants::match_default)
        -: 2230:    { return regex_search(__s.begin(), __s.end(), __e, __flags); }
        -: 2231:
        -: 2232:  /**
        -: 2233:   * @brief Searches for a regular expression within a string.
        -: 2234:   * @param __s [IN]  A C++ string to search for the regex.
        -: 2235:   * @param __m [OUT] The set of regex matches.
        -: 2236:   * @param __e [IN]  The regex to search for in @p s.
        -: 2237:   * @param __f [IN]  The search flags.
        -: 2238:   * @retval true  A match was found within the string.
        -: 2239:   * @retval false No match was found within the string, the content of %m is
        -: 2240:   *               undefined.
        -: 2241:   *
        -: 2242:   * @throws an exception of type regex_error.
        -: 2243:   */
        -: 2244:  template<typename _Ch_traits, typename _Ch_alloc,
        -: 2245:	   typename _Alloc, typename _Ch_type,
        -: 2246:	   typename _Rx_traits>
        -: 2247:    inline bool
        -: 2248:    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,
        -: 2249:		 match_results<typename basic_string<_Ch_type,
        -: 2250:		 _Ch_traits, _Ch_alloc>::const_iterator, _Alloc>& __m,
        -: 2251:		 const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2252:		 regex_constants::match_flag_type __f
        -: 2253:		 = regex_constants::match_default)
        -: 2254:    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }
        -: 2255:
        -: 2256:  // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 2257:  // 2329. regex_search() with match_results should forbid temporary strings
        -: 2258:  /// Prevent unsafe attempts to get match_results from a temporary string.
        -: 2259:  template<typename _Ch_traits, typename _Ch_alloc,
        -: 2260:	   typename _Alloc, typename _Ch_type,
        -: 2261:	   typename _Rx_traits>
        -: 2262:    bool
        -: 2263:    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>&&,
        -: 2264:		 match_results<typename basic_string<_Ch_type,
        -: 2265:		 _Ch_traits, _Ch_alloc>::const_iterator, _Alloc>&,
        -: 2266:		 const basic_regex<_Ch_type, _Rx_traits>&,
        -: 2267:		 regex_constants::match_flag_type
        -: 2268:		 = regex_constants::match_default) = delete;
        -: 2269:
        -: 2270:  // std [28.11.4] Function template regex_replace
        -: 2271:  /**
        -: 2272:   * @brief Search for a regular expression within a range for multiple times,
        -: 2273:   and replace the matched parts through filling a format string.
        -: 2274:   * @param __out   [OUT] The output iterator.
        -: 2275:   * @param __first [IN]  The start of the string to search.
        -: 2276:   * @param __last  [IN]  One-past-the-end of the string to search.
        -: 2277:   * @param __e     [IN]  The regular expression to search for.
        -: 2278:   * @param __fmt   [IN]  The format string.
        -: 2279:   * @param __flags [IN]  Search and replace policy flags.
        -: 2280:   *
        -: 2281:   * @returns __out
        -: 2282:   * @throws an exception of type regex_error.
        -: 2283:   */
        -: 2284:  template<typename _Out_iter, typename _Bi_iter,
        -: 2285:	   typename _Rx_traits, typename _Ch_type,
        -: 2286:	   typename _St, typename _Sa>
        -: 2287:    inline _Out_iter
        -: 2288:    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
        -: 2289:		  const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2290:		  const basic_string<_Ch_type, _St, _Sa>& __fmt,
        -: 2291:		  regex_constants::match_flag_type __flags
        -: 2292:		  = regex_constants::match_default)
        -: 2293:    {
        -: 2294:      return regex_replace(__out, __first, __last, __e, __fmt.c_str(), __flags);
        -: 2295:    }
        -: 2296:
        -: 2297:  /**
        -: 2298:   * @brief Search for a regular expression within a range for multiple times,
        -: 2299:   and replace the matched parts through filling a format C-string.
        -: 2300:   * @param __out   [OUT] The output iterator.
        -: 2301:   * @param __first [IN]  The start of the string to search.
        -: 2302:   * @param __last  [IN]  One-past-the-end of the string to search.
        -: 2303:   * @param __e     [IN]  The regular expression to search for.
        -: 2304:   * @param __fmt   [IN]  The format C-string.
        -: 2305:   * @param __flags [IN]  Search and replace policy flags.
        -: 2306:   *
        -: 2307:   * @returns __out
        -: 2308:   * @throws an exception of type regex_error.
        -: 2309:   */
        -: 2310:  template<typename _Out_iter, typename _Bi_iter,
        -: 2311:	   typename _Rx_traits, typename _Ch_type>
        -: 2312:    _Out_iter
        -: 2313:    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
        -: 2314:		  const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2315:		  const _Ch_type* __fmt,
        -: 2316:		  regex_constants::match_flag_type __flags
        -: 2317:		  = regex_constants::match_default);
        -: 2318:
        -: 2319:  /**
        -: 2320:   * @brief Search for a regular expression within a string for multiple times,
        -: 2321:   and replace the matched parts through filling a format string.
        -: 2322:   * @param __s     [IN] The string to search and replace.
        -: 2323:   * @param __e     [IN] The regular expression to search for.
        -: 2324:   * @param __fmt   [IN] The format string.
        -: 2325:   * @param __flags [IN] Search and replace policy flags.
        -: 2326:   *
        -: 2327:   * @returns The string after replacing.
        -: 2328:   * @throws an exception of type regex_error.
        -: 2329:   */
        -: 2330:  template<typename _Rx_traits, typename _Ch_type,
        -: 2331:	   typename _St, typename _Sa, typename _Fst, typename _Fsa>
        -: 2332:    inline basic_string<_Ch_type, _St, _Sa>
        -: 2333:    regex_replace(const basic_string<_Ch_type, _St, _Sa>& __s,
        -: 2334:		  const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2335:		  const basic_string<_Ch_type, _Fst, _Fsa>& __fmt,
        -: 2336:		  regex_constants::match_flag_type __flags
        -: 2337:		  = regex_constants::match_default)
        -: 2338:    {
        -: 2339:      basic_string<_Ch_type, _St, _Sa> __result;
        -: 2340:      regex_replace(std::back_inserter(__result),
        -: 2341:		    __s.begin(), __s.end(), __e, __fmt, __flags);
        -: 2342:      return __result;
        -: 2343:    }
        -: 2344:
        -: 2345:  /**
        -: 2346:   * @brief Search for a regular expression within a string for multiple times,
        -: 2347:   and replace the matched parts through filling a format C-string.
        -: 2348:   * @param __s     [IN] The string to search and replace.
        -: 2349:   * @param __e     [IN] The regular expression to search for.
        -: 2350:   * @param __fmt   [IN] The format C-string.
        -: 2351:   * @param __flags [IN] Search and replace policy flags.
        -: 2352:   *
        -: 2353:   * @returns The string after replacing.
        -: 2354:   * @throws an exception of type regex_error.
        -: 2355:   */
        -: 2356:  template<typename _Rx_traits, typename _Ch_type,
        -: 2357:	   typename _St, typename _Sa>
        -: 2358:    inline basic_string<_Ch_type, _St, _Sa>
        -: 2359:    regex_replace(const basic_string<_Ch_type, _St, _Sa>& __s,
        -: 2360:		  const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2361:		  const _Ch_type* __fmt,
        -: 2362:		  regex_constants::match_flag_type __flags
        -: 2363:		  = regex_constants::match_default)
        -: 2364:    {
        -: 2365:      basic_string<_Ch_type, _St, _Sa> __result;
        -: 2366:      regex_replace(std::back_inserter(__result),
        -: 2367:		    __s.begin(), __s.end(), __e, __fmt, __flags);
        -: 2368:      return __result;
        -: 2369:    }
        -: 2370:
        -: 2371:  /**
        -: 2372:   * @brief Search for a regular expression within a C-string for multiple
        -: 2373:   times, and replace the matched parts through filling a format string.
        -: 2374:   * @param __s     [IN] The C-string to search and replace.
        -: 2375:   * @param __e     [IN] The regular expression to search for.
        -: 2376:   * @param __fmt   [IN] The format string.
        -: 2377:   * @param __flags [IN] Search and replace policy flags.
        -: 2378:   *
        -: 2379:   * @returns The string after replacing.
        -: 2380:   * @throws an exception of type regex_error.
        -: 2381:   */
        -: 2382:  template<typename _Rx_traits, typename _Ch_type,
        -: 2383:	   typename _St, typename _Sa>
        -: 2384:    inline basic_string<_Ch_type>
        -: 2385:    regex_replace(const _Ch_type* __s,
        -: 2386:		  const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2387:		  const basic_string<_Ch_type, _St, _Sa>& __fmt,
        -: 2388:		  regex_constants::match_flag_type __flags
        -: 2389:		  = regex_constants::match_default)
        -: 2390:    {
        -: 2391:      basic_string<_Ch_type> __result;
        -: 2392:      regex_replace(std::back_inserter(__result), __s,
        -: 2393:		    __s + char_traits<_Ch_type>::length(__s),
        -: 2394:		    __e, __fmt, __flags);
        -: 2395:      return __result;
        -: 2396:    }
        -: 2397:
        -: 2398:  /**
        -: 2399:   * @brief Search for a regular expression within a C-string for multiple
        -: 2400:   times, and replace the matched parts through filling a format C-string.
        -: 2401:   * @param __s     [IN] The C-string to search and replace.
        -: 2402:   * @param __e     [IN] The regular expression to search for.
        -: 2403:   * @param __fmt   [IN] The format C-string.
        -: 2404:   * @param __flags [IN] Search and replace policy flags.
        -: 2405:   *
        -: 2406:   * @returns The string after replacing.
        -: 2407:   * @throws an exception of type regex_error.
        -: 2408:   */
        -: 2409:  template<typename _Rx_traits, typename _Ch_type>
        -: 2410:    inline basic_string<_Ch_type>
        -: 2411:    regex_replace(const _Ch_type* __s,
        -: 2412:		  const basic_regex<_Ch_type, _Rx_traits>& __e,
        -: 2413:		  const _Ch_type* __fmt,
        -: 2414:		  regex_constants::match_flag_type __flags
        -: 2415:		  = regex_constants::match_default)
        -: 2416:    {
        -: 2417:      basic_string<_Ch_type> __result;
        -: 2418:      regex_replace(std::back_inserter(__result), __s,
        -: 2419:		    __s + char_traits<_Ch_type>::length(__s),
        -: 2420:		    __e, __fmt, __flags);
        -: 2421:      return __result;
        -: 2422:    }
        -: 2423:
        -: 2424:  //@}
        -: 2425:
        -: 2426:_GLIBCXX_BEGIN_NAMESPACE_CXX11
        -: 2427:
        -: 2428:  // std [28.12] Class template regex_iterator
        -: 2429:  /**
        -: 2430:   * An iterator adaptor that will provide repeated calls of regex_search over
        -: 2431:   * a range until no more matches remain.
        -: 2432:   */
        -: 2433:  template<typename _Bi_iter,
        -: 2434:	   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,
        -: 2435:	   typename _Rx_traits = regex_traits<_Ch_type> >
        -: 2436:    class regex_iterator
        -: 2437:    {
        -: 2438:    public:
        -: 2439:      typedef basic_regex<_Ch_type, _Rx_traits>  regex_type;
        -: 2440:      typedef match_results<_Bi_iter>            value_type;
        -: 2441:      typedef std::ptrdiff_t                     difference_type;
        -: 2442:      typedef const value_type*                  pointer;
        -: 2443:      typedef const value_type&                  reference;
        -: 2444:      typedef std::forward_iterator_tag          iterator_category;
        -: 2445:
        -: 2446:      /**
        -: 2447:       * @brief Provides a singular iterator, useful for indicating
        -: 2448:       * one-past-the-end of a range.
        -: 2449:       */
        -: 2450:      regex_iterator()
        -: 2451:      : _M_match()
        -: 2452:      { }
        -: 2453:
        -: 2454:      /**
        -: 2455:       * Constructs a %regex_iterator...
        -: 2456:       * @param __a  [IN] The start of a text range to search.
        -: 2457:       * @param __b  [IN] One-past-the-end of the text range to search.
        -: 2458:       * @param __re [IN] The regular expression to match.
        -: 2459:       * @param __m  [IN] Policy flags for match rules.
        -: 2460:       */
        -: 2461:      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,
        -: 2462:		     regex_constants::match_flag_type __m
        -: 2463:		     = regex_constants::match_default)
        -: 2464:      : _M_begin(__a), _M_end(__b), _M_pregex(&__re), _M_flags(__m), _M_match()
        -: 2465:      {
        -: 2466:	if (!regex_search(_M_begin, _M_end, _M_match, *_M_pregex, _M_flags))
        -: 2467:	  *this = regex_iterator();
        -: 2468:      }
        -: 2469:
        -: 2470:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 2471:      // 2332. regex_iterator should forbid temporary regexes
        -: 2472:      regex_iterator(_Bi_iter, _Bi_iter, const regex_type&&,
        -: 2473:		     regex_constants::match_flag_type
        -: 2474:		     = regex_constants::match_default) = delete;
        -: 2475:      /**
        -: 2476:       * Copy constructs a %regex_iterator.
        -: 2477:       */
        -: 2478:      regex_iterator(const regex_iterator& __rhs) = default;
        -: 2479:
        -: 2480:      /**
        -: 2481:       * @brief Assigns one %regex_iterator to another.
        -: 2482:       */
        -: 2483:      regex_iterator&
        -: 2484:      operator=(const regex_iterator& __rhs) = default;
        -: 2485:
        -: 2486:      /**
        -: 2487:       * @brief Tests the equivalence of two regex iterators.
        -: 2488:       */
        -: 2489:      bool
        -: 2490:      operator==(const regex_iterator& __rhs) const;
        -: 2491:
        -: 2492:      /**
        -: 2493:       * @brief Tests the inequivalence of two regex iterators.
        -: 2494:       */
        -: 2495:      bool
        -: 2496:      operator!=(const regex_iterator& __rhs) const
        -: 2497:      { return !(*this == __rhs); }
        -: 2498:
        -: 2499:      /**
        -: 2500:       * @brief Dereferences a %regex_iterator.
        -: 2501:       */
        -: 2502:      const value_type&
        -: 2503:      operator*() const
        -: 2504:      { return _M_match; }
        -: 2505:
        -: 2506:      /**
        -: 2507:       * @brief Selects a %regex_iterator member.
        -: 2508:       */
        -: 2509:      const value_type*
        -: 2510:      operator->() const
        -: 2511:      { return &_M_match; }
        -: 2512:
        -: 2513:      /**
        -: 2514:       * @brief Increments a %regex_iterator.
        -: 2515:       */
        -: 2516:      regex_iterator&
        -: 2517:      operator++();
        -: 2518:
        -: 2519:      /**
        -: 2520:       * @brief Postincrements a %regex_iterator.
        -: 2521:       */
        -: 2522:      regex_iterator
        -: 2523:      operator++(int)
        -: 2524:      {
        -: 2525:	auto __tmp = *this;
        -: 2526:	++(*this);
        -: 2527:	return __tmp;
        -: 2528:      }
        -: 2529:
        -: 2530:    private:
        -: 2531:      _Bi_iter                         _M_begin;
        -: 2532:      _Bi_iter                         _M_end;
        -: 2533:      const regex_type*                _M_pregex;
        -: 2534:      regex_constants::match_flag_type _M_flags;
        -: 2535:      match_results<_Bi_iter>          _M_match;
        -: 2536:    };
        -: 2537:
        -: 2538:  typedef regex_iterator<const char*>             cregex_iterator;
        -: 2539:  typedef regex_iterator<string::const_iterator>  sregex_iterator;
        -: 2540:#ifdef _GLIBCXX_USE_WCHAR_T
        -: 2541:  typedef regex_iterator<const wchar_t*>          wcregex_iterator;
        -: 2542:  typedef regex_iterator<wstring::const_iterator> wsregex_iterator;
        -: 2543:#endif
        -: 2544:
        -: 2545:  // [7.12.2] Class template regex_token_iterator
        -: 2546:  /**
        -: 2547:   * Iterates over submatches in a range (or @a splits a text string).
        -: 2548:   *
        -: 2549:   * The purpose of this iterator is to enumerate all, or all specified,
        -: 2550:   * matches of a regular expression within a text range.  The dereferenced
        -: 2551:   * value of an iterator of this class is a std::sub_match object.
        -: 2552:   */
        -: 2553:  template<typename _Bi_iter,
        -: 2554:	   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,
        -: 2555:	   typename _Rx_traits = regex_traits<_Ch_type> >
        -: 2556:    class regex_token_iterator
        -: 2557:    {
        -: 2558:    public:
        -: 2559:      typedef basic_regex<_Ch_type, _Rx_traits> regex_type;
        -: 2560:      typedef sub_match<_Bi_iter>               value_type;
        -: 2561:      typedef std::ptrdiff_t                    difference_type;
        -: 2562:      typedef const value_type*                 pointer;
        -: 2563:      typedef const value_type&                 reference;
        -: 2564:      typedef std::forward_iterator_tag         iterator_category;
        -: 2565:
        -: 2566:    public:
        -: 2567:      /**
        -: 2568:       * @brief Default constructs a %regex_token_iterator.
        -: 2569:       *
        -: 2570:       * A default-constructed %regex_token_iterator is a singular iterator
        -: 2571:       * that will compare equal to the one-past-the-end value for any
        -: 2572:       * iterator of the same type.
        -: 2573:       */
        -: 2574:      regex_token_iterator()
        -: 2575:      : _M_position(), _M_subs(), _M_suffix(), _M_n(0), _M_result(nullptr),
        -: 2576:      _M_has_m1(false)
        -: 2577:      { }
        -: 2578:
        -: 2579:      /**
        -: 2580:       * Constructs a %regex_token_iterator...
        -: 2581:       * @param __a          [IN] The start of the text to search.
        -: 2582:       * @param __b          [IN] One-past-the-end of the text to search.
        -: 2583:       * @param __re         [IN] The regular expression to search for.
        -: 2584:       * @param __submatch   [IN] Which submatch to return.  There are some
        -: 2585:       *                        special values for this parameter:
        -: 2586:       *                        - -1 each enumerated subexpression does NOT
        -: 2587:       *                          match the regular expression (aka field
        -: 2588:       *                          splitting)
        -: 2589:       *                        - 0 the entire string matching the
        -: 2590:       *                          subexpression is returned for each match
        -: 2591:       *                          within the text.
        -: 2592:       *                        - >0 enumerates only the indicated
        -: 2593:       *                          subexpression from a match within the text.
        -: 2594:       * @param __m          [IN] Policy flags for match rules.
        -: 2595:       */
        -: 2596:      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,
        -: 2597:			   int __submatch = 0,
        -: 2598:			   regex_constants::match_flag_type __m
        -: 2599:			   = regex_constants::match_default)
        -: 2600:      : _M_position(__a, __b, __re, __m), _M_subs(1, __submatch), _M_n(0)
        -: 2601:      { _M_init(__a, __b); }
        -: 2602:
        -: 2603:      /**
        -: 2604:       * Constructs a %regex_token_iterator...
        -: 2605:       * @param __a          [IN] The start of the text to search.
        -: 2606:       * @param __b          [IN] One-past-the-end of the text to search.
        -: 2607:       * @param __re         [IN] The regular expression to search for.
        -: 2608:       * @param __submatches [IN] A list of subexpressions to return for each
        -: 2609:       *                          regular expression match within the text.
        -: 2610:       * @param __m          [IN] Policy flags for match rules.
        -: 2611:       */
        -: 2612:      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,
        -: 2613:			   const regex_type& __re,
        -: 2614:			   const std::vector<int>& __submatches,
        -: 2615:			   regex_constants::match_flag_type __m
        -: 2616:			     = regex_constants::match_default)
        -: 2617:      : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)
        -: 2618:      { _M_init(__a, __b); }
        -: 2619:
        -: 2620:      /**
        -: 2621:       * Constructs a %regex_token_iterator...
        -: 2622:       * @param __a          [IN] The start of the text to search.
        -: 2623:       * @param __b          [IN] One-past-the-end of the text to search.
        -: 2624:       * @param __re         [IN] The regular expression to search for.
        -: 2625:       * @param __submatches [IN] A list of subexpressions to return for each
        -: 2626:       *                          regular expression match within the text.
        -: 2627:       * @param __m          [IN] Policy flags for match rules.
        -: 2628:       */
        -: 2629:      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,
        -: 2630:			   const regex_type& __re,
        -: 2631:			   initializer_list<int> __submatches,
        -: 2632:			   regex_constants::match_flag_type __m
        -: 2633:			     = regex_constants::match_default)
        -: 2634:      : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)
        -: 2635:      { _M_init(__a, __b); }
        -: 2636:
        -: 2637:      /**
        -: 2638:       * Constructs a %regex_token_iterator...
        -: 2639:       * @param __a          [IN] The start of the text to search.
        -: 2640:       * @param __b          [IN] One-past-the-end of the text to search.
        -: 2641:       * @param __re         [IN] The regular expression to search for.
        -: 2642:       * @param __submatches [IN] A list of subexpressions to return for each
        -: 2643:       *                          regular expression match within the text.
        -: 2644:       * @param __m          [IN] Policy flags for match rules.
        -: 2645:       */
        -: 2646:      template<std::size_t _Nm>
        -: 2647:	regex_token_iterator(_Bi_iter __a, _Bi_iter __b,
        -: 2648:			     const regex_type& __re,
        -: 2649:			     const int (&__submatches)[_Nm],
        -: 2650:			     regex_constants::match_flag_type __m
        -: 2651:			     = regex_constants::match_default)
        -: 2652:      : _M_position(__a, __b, __re, __m),
        -: 2653:      _M_subs(__submatches, __submatches + _Nm), _M_n(0)
        -: 2654:      { _M_init(__a, __b); }
        -: 2655:
        -: 2656:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 2657:      // 2332. regex_token_iterator should forbid temporary regexes
        -: 2658:      regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&, int = 0,
        -: 2659:			   regex_constants::match_flag_type =
        -: 2660:			   regex_constants::match_default) = delete;
        -: 2661:      regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,
        -: 2662:			   const std::vector<int>&,
        -: 2663:			   regex_constants::match_flag_type =
        -: 2664:			   regex_constants::match_default) = delete;
        -: 2665:      regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,
        -: 2666:			   initializer_list<int>,
        -: 2667:			   regex_constants::match_flag_type =
        -: 2668:			   regex_constants::match_default) = delete;
        -: 2669:      template <std::size_t N>
        -: 2670:	regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,
        -: 2671:			     const int (&)[N],
        -: 2672:			     regex_constants::match_flag_type =
        -: 2673:			     regex_constants::match_default) = delete;
        -: 2674:
        -: 2675:      /**
        -: 2676:       * @brief Copy constructs a %regex_token_iterator.
        -: 2677:       * @param __rhs [IN] A %regex_token_iterator to copy.
        -: 2678:       */
        -: 2679:      regex_token_iterator(const regex_token_iterator& __rhs)
        -: 2680:      : _M_position(__rhs._M_position), _M_subs(__rhs._M_subs),
        -: 2681:      _M_suffix(__rhs._M_suffix), _M_n(__rhs._M_n), _M_has_m1(__rhs._M_has_m1)
        -: 2682:      { _M_normalize_result(); }
        -: 2683:
        -: 2684:      /**
        -: 2685:       * @brief Assigns a %regex_token_iterator to another.
        -: 2686:       * @param __rhs [IN] A %regex_token_iterator to copy.
        -: 2687:       */
        -: 2688:      regex_token_iterator&
        -: 2689:      operator=(const regex_token_iterator& __rhs);
        -: 2690:
        -: 2691:      /**
        -: 2692:       * @brief Compares a %regex_token_iterator to another for equality.
        -: 2693:       */
        -: 2694:      bool
        -: 2695:      operator==(const regex_token_iterator& __rhs) const;
        -: 2696:
        -: 2697:      /**
        -: 2698:       * @brief Compares a %regex_token_iterator to another for inequality.
        -: 2699:       */
        -: 2700:      bool
        -: 2701:      operator!=(const regex_token_iterator& __rhs) const
        -: 2702:      { return !(*this == __rhs); }
        -: 2703:
        -: 2704:      /**
        -: 2705:       * @brief Dereferences a %regex_token_iterator.
        -: 2706:       */
        -: 2707:      const value_type&
        -: 2708:      operator*() const
        -: 2709:      { return *_M_result; }
        -: 2710:
        -: 2711:      /**
        -: 2712:       * @brief Selects a %regex_token_iterator member.
        -: 2713:       */
        -: 2714:      const value_type*
        -: 2715:      operator->() const
        -: 2716:      { return _M_result; }
        -: 2717:
        -: 2718:      /**
        -: 2719:       * @brief Increments a %regex_token_iterator.
        -: 2720:       */
        -: 2721:      regex_token_iterator&
        -: 2722:      operator++();
        -: 2723:
        -: 2724:      /**
        -: 2725:       * @brief Postincrements a %regex_token_iterator.
        -: 2726:       */
        -: 2727:      regex_token_iterator
        -: 2728:      operator++(int)
        -: 2729:      {
        -: 2730:	auto __tmp = *this;
        -: 2731:	++(*this);
        -: 2732:	return __tmp;
        -: 2733:      }
        -: 2734:
        -: 2735:    private:
        -: 2736:      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> _Position;
        -: 2737:
        -: 2738:      void
        -: 2739:      _M_init(_Bi_iter __a, _Bi_iter __b);
        -: 2740:
        -: 2741:      const value_type&
        -: 2742:      _M_current_match() const
        -: 2743:      {
        -: 2744:	if (_M_subs[_M_n] == -1)
        -: 2745:	  return (*_M_position).prefix();
        -: 2746:	else
        -: 2747:	  return (*_M_position)[_M_subs[_M_n]];
        -: 2748:      }
        -: 2749:
        -: 2750:      constexpr bool
        -: 2751:      _M_end_of_seq() const
        -: 2752:      { return _M_result == nullptr; }
        -: 2753:
        -: 2754:      // [28.12.2.2.4]
        -: 2755:      void
        -: 2756:      _M_normalize_result()
        -: 2757:      {
        -: 2758:	if (_M_position != _Position())
        -: 2759:	  _M_result = &_M_current_match();
        -: 2760:	else if (_M_has_m1)
        -: 2761:	  _M_result = &_M_suffix;
        -: 2762:	else
        -: 2763:	  _M_result = nullptr;
        -: 2764:      }
        -: 2765:
        -: 2766:      _Position         _M_position;
        -: 2767:      std::vector<int>  _M_subs;
        -: 2768:      value_type        _M_suffix;
        -: 2769:      std::size_t       _M_n;
        -: 2770:      const value_type* _M_result;
        -: 2771:
        -: 2772:      // Show whether _M_subs contains -1
        -: 2773:      bool              _M_has_m1;
        -: 2774:    };
        -: 2775:
        -: 2776:  /** @brief Token iterator for C-style NULL-terminated strings. */
        -: 2777:  typedef regex_token_iterator<const char*>             cregex_token_iterator;
        -: 2778:
        -: 2779:  /** @brief Token iterator for standard strings. */
        -: 2780:  typedef regex_token_iterator<string::const_iterator>  sregex_token_iterator;
        -: 2781:
        -: 2782:#ifdef _GLIBCXX_USE_WCHAR_T
        -: 2783:  /** @brief Token iterator for C-style NULL-terminated wide strings. */
        -: 2784:  typedef regex_token_iterator<const wchar_t*>          wcregex_token_iterator;
        -: 2785:
        -: 2786:  /** @brief Token iterator for standard wide-character strings. */
        -: 2787:  typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
        -: 2788:#endif
        -: 2789:
        -: 2790:  //@} // group regex
        -: 2791:
        -: 2792:_GLIBCXX_END_NAMESPACE_CXX11
        -: 2793:_GLIBCXX_END_NAMESPACE_VERSION
        -: 2794:} // namespace
        -: 2795:
        -: 2796:#include <bits/regex.tcc>
